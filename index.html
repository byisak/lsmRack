<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>파렛트 랙 시각화</title>
    <!-- Tailwind CSS CDN (예시 버전) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.5/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/stats-js@1.0.1/build/stats.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
      integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    />

    <style>
      @font-face {
        font-family: 'MinSans';
        src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_2201-2@1.0/MinSans-Regular.woff')
          format('woff');
      }

      .font-MinSans {
        font-family: MinSans, ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont,
          'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Noto Sans', sans-serif, 'Apple Color Emoji',
          'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';
      }
      /* 캔버스, 로딩 화면, 툴팁 등 기본 스타일 */
      #canvas-container {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }
      #loading-screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        color: white;
        font-size: 20px;
        z-index: 100;
      }
      .progress-bar {
        width: 50%;
        height: 10px;
        background-color: #444;
        border-radius: 5px;
        margin-top: 20px;
      }
      .progress-bar-fill {
        height: 100%;
        background-color: #0088ff;
        border-radius: 5px;
        width: 0%;
        transition: width 0.3s ease;
      }
      /* 모달 스타일 */
      .modal {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 1000;
        width: 600px;
        max-width: 90%;
        max-height: 90vh;
        overflow: auto;
        display: none; /* 초기 상태를 none으로 설정 */
      }
      #preview-canvas {
        width: 100% !important;
        height: 200px !important; /* 고정된 높이 */
        max-width: 100%;
        display: block;
      }
      /* 툴팁 스타일 - 세련된 다크 테마 */
      .tooltip {
        position: fixed;
        background: rgba(31, 41, 55, 0.95); /* bg-gray-800/95 */
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
        color: white;
        padding: 12px 16px;
        border-radius: 12px;
        border: 1px solid rgba(75, 85, 99, 0.5); /* border-gray-600/50 */
        font-size: 13px;
        line-height: 1.6;
        pointer-events: none;
        z-index: 100;
        display: none;
        min-width: 180px;
        max-width: 280px;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5), 0 0 0 1px rgba(255, 255, 255, 0.05);
        animation: tooltipFadeIn 0.2s ease-out;
      }

      @keyframes tooltipFadeIn {
        from {
          opacity: 0;
          transform: translateY(-5px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .tooltip-header {
        font-weight: 600;
        font-size: 14px;
        color: #60a5fa; /* blue-400 */
        margin-bottom: 8px;
        padding-bottom: 6px;
        border-bottom: 1px solid rgba(75, 85, 99, 0.3);
      }

      .tooltip-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin: 4px 0;
        font-size: 12px;
      }

      .tooltip-label {
        color: #9ca3af; /* gray-400 */
        font-weight: 500;
      }

      .tooltip-value {
        color: #f3f4f6; /* gray-100 */
        font-weight: 500;
        text-align: right;
      }

      .tooltip-empty {
        color: #6b7280; /* gray-500 */
        font-style: italic;
        text-align: center;
        padding: 4px 0;
      }
      /* 툴박스 스타일 */
      #rack-toolbar {
        width: 200px;
        border: 1px solid rgba(0, 0, 0, 0.1);
      }

      .thumbnail {
        width: 60px;
        height: 60px;
        object-fit: cover;
        border: 2px solid transparent;
        border-radius: 4px;
        cursor: pointer;
        transition: border-color 0.2s;
      }
      .thumbnail.selected {
        border-color: #3b82f6; /* 선택된 썸네일 테두리 색상 */
      }
      .thumbnail:hover {
        border-color: #93c5fd;
      }
      .distance-label {
        font-size: 14px;
        background: #ff8800;
        border: 1px solid #ff8800;
        color: #fff;
        padding: 2px 4px;
        border-radius: 4px;
        pointer-events: auto;
        cursor: pointer;
      }
      /* Chrome, Safari, Edge */
      .distance-label input[type='number']::-webkit-outer-spin-button,
      .distance-label input[type='number']::-webkit-inner-spin-button {
        -webkit-appearance: none;
        margin: 0;
      }

      /* Firefox */
      .distance-label input[type='number'] {
        -moz-appearance: textfield;
        appearance: textfield;
      }

      /* ===== 그라디언트 검색 인풋 스타일 ===== */
      .search-input-container {
        position: relative;
        width: 400px;
      }

      /* Gradient shadow effect */
      .gradient-shadow {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        border-radius: 24px;
        background: linear-gradient(45deg, #ff6ec4, #7873f5, #4fc3f7, #66bb6a, #ffca28, #ff6ec4);
        background-size: 300% 300%;
        opacity: 0;
        filter: blur(20px);
        transition: opacity 0.3s ease;
        animation: gradientShift 3s ease infinite;
        z-index: 0;
      }

      /* Gradient border wrapper */
      .input-wrapper {
        position: relative;
        border-radius: 24px;
        padding: 2px;
        background: transparent; /* 기본 상태는 투명 */
        transition: all 0.3s ease;
      }

      /* Show gradient border on focus */
      .search-input-container:focus-within .input-wrapper {
        background: linear-gradient(45deg, #ff6ec4, #7873f5, #4fc3f7, #66bb6a, #ffca28, #ff6ec4);
        background-size: 300% 300%;
        animation: gradientShift 3s ease infinite;
      }

      /* Show gradient shadow on focus */
      .search-input-container:focus-within .gradient-shadow {
        opacity: 0.4;
      }

      /* Search input field */
      #search-input {
        width: 100%;
        padding: 14px 50px 14px 24px;
        font-size: 15px;
        border: none;
        border-radius: 22px;
        background: white;
        outline: none;
        transition: all 0.3s ease;
        position: relative;
        z-index: 1;
      }

      /* Default border when not focused */
      .search-input-container:not(:focus-within) #search-input {
        border: 1px solid rgba(0, 0, 0, 0.1);
        border-radius: 24px;
      }

      #search-input::placeholder {
        color: #999;
      }

      /* Animation for gradient movement */
      @keyframes gradientShift {
        0% {
          background-position: 0% 50%;
        }
        50% {
          background-position: 100% 50%;
        }
        100% {
          background-position: 0% 50%;
        }
      }

      /* Search button inside input */
      #search-btn {
        position: absolute;
        right: 6px;
        top: 50%;
        transform: translateY(-50%);
        z-index: 3;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        border: none;
        padding: 8px 16px;
        border-radius: 18px;
        color: white;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
      }

      #search-btn:hover {
        transform: translateY(-50%) scale(1.05);
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.5);
      }

      #search-btn:active {
        transform: translateY(-50%) scale(0.98);
      }

      /* Loading spinner */
      .search-loading-icon {
        position: absolute;
        right: 80px;
        top: 50%;
        transform: translateY(-50%);
        z-index: 3;
        width: 18px;
        height: 18px;
        opacity: 0;
        transition: opacity 0.3s ease;
        pointer-events: none;
      }

      .search-input-container:focus-within .search-loading-icon {
        opacity: 1;
      }

      .search-spinner {
        width: 18px;
        height: 18px;
        border: 2px solid transparent;
        border-top-color: #7873f5;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      /* 브라우저 기본 드롭다운 마커 감추기 */
      #rack-tree summary::-webkit-details-marker {
        display: none;
      }
      #rack-tree summary::marker {
        display: none;
      }
      #left-panel {
        max-height: calc(100vh - 2rem);
        overflow-y: auto;
        overflow-x: hidden;
      }

      /* Webkit 기반 브라우저 */
      #left-panel::-webkit-scrollbar {
        width: 6px;
      }
      #left-panel::-webkit-scrollbar-track {
        background: #374151; /* gray-700 */
        border-radius: 3px;
      }
      #left-panel::-webkit-scrollbar-thumb {
        background-color: #4b5563; /* gray-600 */
        border-radius: 3px;
      }

      /* Firefox */
      #left-panel {
        scrollbar-width: thin;
        scrollbar-color: #4b5563 #374151;
      }
      /*
      #rack-tree summary {
        caret-color: transparent;
      }
        */

      /* 1) h4, label 등 포커스 가능한 텍스트 요소에 대해 */
      h4:focus,
      label:focus {
        outline: none; /* 포커스 테두리 제거 */
        caret-color: transparent !important; /* 깜박이는 커서(캐럿) 숨기기 */
      }

      /* 2) 추가로, 스팬·단락 등 다른 텍스트에도 동일하게 적용하고 싶다면 */
      h1:focus,
      h2:focus,
      h3:focus,
      p:focus,
      span:focus,
      ul:focus,
      li:focus {
        outline: none;
        caret-color: transparent !important;
      }

      /* 3) 클릭만으로 포커스가 가지 않게 하고 싶으면 user-select: none 도 함께 */
      h4,
      label {
        user-select: none;
      }
      /* number input 스피너 제거 */
      input[type='number']::-webkit-outer-spin-button,
      input[type='number']::-webkit-inner-spin-button {
        -webkit-appearance: none;
        margin: 0;
      }
      input[type='number'] {
        -moz-appearance: textfield;
        appearance: textfield;
      }
      /* 공통 슬라이더 스타일 */
      .slider {
        -webkit-appearance: none;
        appearance: none;
        width: 100%;
        height: 24px;
        border-radius: 8px;
        background: linear-gradient(
          to right,
          #3b82f6 0%,
          #3b82f6 var(--percent),
          #4a4a4a var(--percent),
          #4a4a4a 100%
        );
        outline: none;
        cursor: pointer;
      }
      .slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 12px;
        height: 24px;
        border-radius: 6px;
        background: #848484;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
      }
      .slider::-moz-range-thumb {
        width: 12px;
        height: 24px;
        border-radius: 6px;
        background: #848484;
        border: none;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
      }
      .floor-anchor button {
        transition: background-color 0.2s;
      }
      .floor-anchor button.selected {
        background-color: #f59e0b; /* 방향 선택 강조 색 */
      }
    </style>
  </head>
  <body class="font-MinSans">
    <!-- Three.js 렌더링 영역 -->
    <div id="canvas-container"></div>

    <!-- 로딩 화면 -->
    <div id="loading-screen">
      <div>파렛트 랙 로딩 중...</div>
      <div class="progress-bar">
        <div class="progress-bar-fill" id="progress-fill"></div>
      </div>
    </div>

    <div id="modal-overlay" class="fixed inset-0 bg-black/50 z-40" style="display: none"></div>

    <!-- 툴박스 (선택된 랙 위에 표시) -->
    <div
      id="rack-toolbar"
      class="hidden fixed bg-white/90 backdrop-blur-md p-3 rounded-lg shadow-lg z-50 space-y-2 text-black"
    >
      <div class="flex justify-between items-center mb-2">
        <h4 class="text-sm font-bold">랙 설정</h4>
        <button id="toolbar-close" class="text-lg cursor-pointer">×</button>
      </div>
      <div class="grid grid-cols-2 gap-2">
        <!-- 랙 ID 입력 필드 추가 -->
        <div class="col-span-2">
          <label class="block text-xs">랙 ID</label>
          <input
            id="toolbar-rack-id"
            type="text"
            class="w-full p-1 rounded text-black outline outline-gray-200 text-sm"
          />
        </div>
        <div>
          <label class="block text-xs">폭</label>
          <input
            id="toolbar-rack-width"
            type="number"
            step="0.1"
            class="w-full p-1 rounded text-black outline outline-gray-200 text-sm"
          />
        </div>
        <div>
          <label class="block text-xs">깊이</label>
          <input
            id="toolbar-rack-depth"
            type="number"
            step="0.1"
            class="w-full p-1 rounded text-black outline outline-gray-200 text-sm"
          />
        </div>
        <div>
          <label class="block text-xs">높이</label>
          <input
            id="toolbar-rack-height"
            type="number"
            step="0.1"
            class="w-full p-1 rounded text-black outline outline-gray-200 text-sm"
          />
        </div>
        <div>
          <label class="block text-xs">단 수</label>
          <input
            id="toolbar-rack-levels"
            type="number"
            step="1"
            class="w-full p-1 rounded text-black outline outline-gray-200 text-sm"
          />
        </div>
        <div>
          <label class="block text-xs">셀 수</label>
          <input
            id="toolbar-rack-cells"
            type="number"
            step="1"
            class="w-full p-1 rounded text-black outline outline-gray-200 text-sm"
          />
        </div>
        <div>
          <label class="block text-xs">회전</label>
          <input
            id="toolbar-rack-rotation"
            type="number"
            min="-180"
            max="180"
            step="5"
            class="w-full p-1 rounded text-black outline outline-gray-200 text-sm"
          />
        </div>
      </div>
      <div class="flex space-x-2">
        <button id="toolbar-apply" class="w-1/2 bg-blue-500 py-1 rounded text-sm">적용</button>
        <button id="toolbar-delete" class="w-1/2 bg-red-500 py-1 rounded text-sm">삭제</button>
      </div>
    </div>
    <!-- 그라디언트 검색 바 -->
    <div id="search-bar" class="fixed top-5 left-1/2 transform -translate-x-1/2 z-50">
      <div class="search-input-container">
        <div class="gradient-shadow"></div>
        <div class="input-wrapper">
          <input id="search-input" type="text" placeholder="품목코드 입력하세요..." />
        </div>
        <div class="search-loading-icon">
          <div class="search-spinner"></div>
        </div>
        <button id="search-btn">검색</button>
      </div>
    </div>

    <div
      id="rack-config-panel"
      class="absolute top-4 right-3 bottom-4 w-[230px] h-[600px] bg-gray-800/60 backdrop-blur-md border border-gray-700 rounded-2xl shadow-xl z-50 overflow-y-auto p-4"
    >
      <!-- 1) 탭 네비게이션 추가 -->
      <ul class="flex bg-gray-800 shadow-lg w-full rounded-xl mb-4">
        <li
          id="tab1"
          class="tab flex-1 flex flex-col items-center py-2 cursor-pointer text-yellow-300 border-b-2 border-yellow-300"
        >
          <!-- 입체 사각형 아이콘 -->
          <svg
            xmlns="http://www.w3.org/2000/svg"
            fill="currentColor"
            class="w-4 h-4 mb-1"
            viewBox="0 0 511 512"
          >
            <path
              d="M498.7 222.7L289.8 13.8C280.9 4.9 269.1 0 256.5 0s-24.4 4.9-33.3 13.8L14.4 222.6c-18.3 18.4-18.3 48.2 0.1 66.6
                     8.4 8.4 19.4 13.2 31.3 13.7h8.3v153.7c0 30.4 24.8 55.2 55.2 55.2h81.7c8.3 0 15-6.7 15-15V376.5
                     c0-13.9 11.3-25.2 25.2-25.2h48.2c13.9 0 25.2 11.3 25.2 25.2v153.7c0 8.3 6.7 15 15 15h81.7c30.4 0 55.2-24.8 55.2-55.2
                     V303.1h7.7c12.6 0 24.4-4.9 33.3-13.8 18.4-18.4 18.4-48.3 0-66.6z"
            />
          </svg>
          <!-- 랙 설정-->
        </li>
        <li
          id="tab2"
          class="tab flex-1 flex flex-col items-center py-2 cursor-pointer text-slate-400 hover:text-yellow-300"
        >
          <!-- Settings 아이콘 -->
          <svg
            xmlns="http://www.w3.org/2000/svg"
            stroke="currentColor"
            class="w-4 h-4 mb-1"
            viewBox="0 0 682.667 682.667"
          >
            <g transform="matrix(1.33 0 0 -1.33 0 682.667)">
              <path
                fill="none"
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-miterlimit="10"
                stroke-width="40"
                d="M256 334.7c-43.4 0-78.7-35.2-78.7-78.7 0-43.4 35.3-78.7 78.7-78.7
                       43.4 0 78.7 35.2 78.7 78.7 0 43.4-35.3 78.7-78.7 78.7zm220.8-22.5l-21.3-17.5
                       c-24.3-20.0-24.3-57.2 0-77.2l21.3-17.5c7.5-6.2 9.5-17.0 4.6-25.4l-42.1-72.8
                       c-4.9-8.5-15.2-12.2-24.3-8.7l-25.8 9.7c-29.5 11.0-61.7-7.6-66.9-38.6l-4.5-27.2
                       c-1.6-9.6-10.0-16.7-19.7-16.7h-84.1c-9.8 0-18.1 7.1-19.7 16.7l-4.5 27.2
                       c-5.2 31.0-37.4 49.6-66.9 38.6l-25.8-9.7c-9.2-3.4-19.4.3-24.3 8.7l-42.1 72.8
                       c-4.9 8.5-2.9 19.2 4.6 25.4l21.3 17.5c24.3 20.0 24.3 57.2 0 77.2l-21.3 17.5
                       c-7.5 6.2-9.5 17.0-4.6 25.4l42.1 72.8c4.9 8.5 15.2 12.2 24.3 8.7l25.8-9.7
                       c29.5-11.0 61.7 7.6 66.9 38.6l4.5 27.2c1.6 9.6 10.0 16.7 19.7 16.7h84.1
                       c9.8 0 18.1-7.1 19.7-16.7l4.5-27.2c5.2-31.0 37.4-49.6 66.9-38.6l25.8 9.7
                       c9.2 3.4 19.4-.3 24.3-8.7l42.1-72.8c4.9-8.5 2.9-19.2-4.6-25.4z"
              />
            </g>
          </svg>
          <!--추가 설정-->
        </li>
        <li
          id="tab3"
          class="tab flex-1 flex flex-col items-center py-2 cursor-pointer text-slate-400 hover:text-yellow-300"
        >
          <!-- 바닥 설정 아이콘 -->
          <svg
            xmlns="http://www.w3.org/2000/svg"
            stroke="currentColor"
            class="w-4 h-4 mb-1"
            viewBox="0 0 682.667 682.667"
          >
            <g transform="matrix(1.33 0 0 -1.33 0 682.667)">
              <path
                fill="none"
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-miterlimit="10"
                stroke-width="40"
                d="M256 334.7c-43.4 0-78.7-35.2-78.7-78.7 0-43.4 35.3-78.7 78.7-78.7
                       43.4 0 78.7 35.2 78.7 78.7 0 43.4-35.3 78.7-78.7 78.7zm220.8-22.5l-21.3-17.5
                       c-24.3-20.0-24.3-57.2 0-77.2l21.3-17.5c7.5-6.2 9.5-17.0 4.6-25.4l-42.1-72.8
                       c-4.9-8.5-15.2-12.2-24.3-8.7l-25.8 9.7c-29.5 11.0-61.7-7.6-66.9-38.6l-4.5-27.2
                       c-1.6-9.6-10.0-16.7-19.7-16.7h-84.1c-9.8 0-18.1 7.1-19.7 16.7l-4.5 27.2
                       c-5.2 31.0-37.4 49.6-66.9 38.6l-25.8-9.7c-9.2-3.4-19.4.3-24.3 8.7l-42.1 72.8
                       c-4.9 8.5-2.9 19.2 4.6 25.4l21.3 17.5c24.3 20.0 24.3 57.2 0 77.2l-21.3 17.5
                       c-7.5 6.2-9.5 17.0-4.6 25.4l42.1 72.8c4.9 8.5 15.2 12.2 24.3 8.7l25.8-9.7
                       c29.5-11.0 61.7 7.6 66.9 38.6l4.5 27.2c1.6 9.6 10.0 16.7 19.7 16.7h84.1
                       c9.8 0 18.1-7.1 19.7-16.7l4.5-27.2c5.2-31.0 37.4-49.6 66.9-38.6l25.8 9.7
                       c9.2 3.4 19.4-.3 24.3-8.7l42.1-72.8c4.9-8.5 2.9-19.2-4.6-25.4z"
              />
            </g>
          </svg>
          <!--추가 설정-->
        </li>
        <li
          id="tab4"
          class="tab flex-1 flex flex-col items-center py-2 cursor-pointer text-slate-400 hover:text-yellow-300"
        >
          <!-- 사용자 관리 아이콘 -->
          <svg
            xmlns="http://www.w3.org/2000/svg"
            stroke="currentColor"
            class="w-4 h-4 mb-1"
            viewBox="0 0 682.667 682.667"
          >
            <g transform="matrix(1.33 0 0 -1.33 0 682.667)">
              <path
                fill="none"
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-miterlimit="10"
                stroke-width="40"
                d="M256 334.7c-43.4 0-78.7-35.2-78.7-78.7 0-43.4 35.3-78.7 78.7-78.7
                       43.4 0 78.7 35.2 78.7 78.7 0 43.4-35.3 78.7-78.7 78.7zm220.8-22.5l-21.3-17.5
                       c-24.3-20.0-24.3-57.2 0-77.2l21.3-17.5c7.5-6.2 9.5-17.0 4.6-25.4l-42.1-72.8
                       c-4.9-8.5-15.2-12.2-24.3-8.7l-25.8 9.7c-29.5 11.0-61.7-7.6-66.9-38.6l-4.5-27.2
                       c-1.6-9.6-10.0-16.7-19.7-16.7h-84.1c-9.8 0-18.1 7.1-19.7 16.7l-4.5 27.2
                       c-5.2 31.0-37.4 49.6-66.9 38.6l-25.8-9.7c-9.2-3.4-19.4.3-24.3 8.7l-42.1 72.8
                       c-4.9 8.5-2.9 19.2 4.6 25.4l21.3 17.5c24.3 20.0 24.3 57.2 0 77.2l-21.3 17.5
                       c-7.5 6.2-9.5 17.0-4.6 25.4l42.1 72.8c4.9 8.5 15.2 12.2 24.3 8.7l25.8-9.7
                       c29.5-11.0 61.7 7.6 66.9 38.6l4.5 27.2c1.6 9.6 10.0 16.7 19.7 16.7h84.1
                       c9.8 0 18.1-7.1 19.7-16.7l4.5-27.2c5.2-31.0 37.4-49.6 66.9-38.6l25.8 9.7
                       c9.2 3.4 19.4-.3 24.3-8.7l42.1-72.8c4.9-8.5 2.9-19.2-4.6-25.4z"
              />
            </g>
          </svg>
          <!--추가 설정-->
        </li>
      </ul>

      <!-- 2) 탭 콘텐츠: 첫 번째(랙 설정) -->
      <div id="content1" class="tab-content block">
        <!-- 랙 아이디 -->
        <div class="flex items-center space-x-2 mt-2">
          <span class="text-xs w-32 font-medium text-white whitespace-nowrap">랙 아이디</span>
          <div class="grid grid-cols-1 gap-1 w-60">
            <input
              id="cfg-rack-id"
              type="text"
              class="h-[24px] px-2 w-full bg-gray-700 text-white text-xs rounded-lg"
            />
          </div>
        </div>
        <!-- 크기 (W · D) -->
        <div class="flex items-center space-x-2 mt-2">
          <span class="text-xs w-32 font-medium text-white whitespace-nowrap">랙 너비</span>
          <div class="grid grid-cols-1 gap-1 w-60">
            <input
              id="cfg-width"
              type="number"
              step="0.1"
              placeholder="W"
              class="h-[24px] px-2 w-full bg-gray-700 text-white text-xs rounded-lg"
            />
          </div>
        </div>

        <div class="flex items-center space-x-2 mt-2">
          <span class="text-xs w-32 font-medium text-white whitespace-nowrap">랙 폭</span>
          <div class="grid grid-cols-1 gap-1 w-60">
            <input
              id="cfg-depth"
              type="number"
              step="0.1"
              placeholder="L"
              class="h-[24px] px-2 w-full bg-gray-700 text-white text-xs rounded-lg"
            />
          </div>
        </div>

        <!-- 높이 (H) -->
        <div class="flex items-center space-x-2 mt-2">
          <span class="text-xs w-32 font-medium text-white whitespace-nowrap">높이</span>
          <div class="grid grid-cols-1 gap-1 w-60">
            <input
              id="cfg-height"
              type="number"
              step="0.1"
              placeholder="H"
              class="h-[24px] px-2 w-full bg-gray-700 text-white text-xs rounded-lg"
            />
          </div>
        </div>

        <!-- 단 수 · 셀 수 -->
        <div class="flex items-center space-x-2 mt-2">
          <span class="text-xs w-32 font-medium text-gray-300">단 수 · 셀 수</span>
          <div class="grid grid-cols-2 gap-1 w-60">
            <input
              id="cfg-levels"
              type="number"
              step="1"
              placeholder="단 수"
              class="h-[24px] px-2 w-full bg-gray-700 text-white text-xs rounded-lg"
            />
            <input
              id="cfg-cells"
              type="number"
              step="1"
              placeholder="셀 수"
              class="h-[24px] px-2 w-full bg-gray-700 text-white text-xs rounded-lg"
            />
          </div>
        </div>

        <!-- 회전각도 -->
        <div class="flex items-center space-x-2 mt-2">
          <span class="text-xs w-32 font-medium text-white whitespace-nowrap">회전각도</span>
          <div class="flex items-center space-x-2 w-60 min-w-0">
            <input
              id="cfg-rotation-value"
              type="number"
              value="0"
              min="0"
              max="360"
              class="w-12 h-[24px] px-1 bg-gray-700 text-white text-xs rounded-lg focus:outline-none text-right"
            />
            <input
              id="cfg-rotation-range"
              type="range"
              min="0"
              max="360"
              value="180"
              class="slider"
              style="--percent: 50%"
            />
          </div>
        </div>

        <!-- 그룹 선택 -->
        <div class="flex items-center space-x-2 mt-2">
          <span class="text-xs w-32 font-medium text-gray-300">그룹</span>
          <div class="grid grid-cols-1 gap-1 w-60">
            <select
              id="cfg-group-select"
              class="h-[24px] px-2 w-full bg-gray-700 text-white text-xs rounded-lg"
            ></select>
          </div>
        </div>
      </div>

      <!-- 3) 탭 콘텐츠: 두 번째(추가 설정) -->
      <div id="content2" class="tab-content hidden">
        <h4 class="text-xs font-medium text-white mb-2">화면설정</h4>

        <!-- 토글 -->
        <div class="flex items-center space-x-2 mt-2">
          <span class="text-xs w-32 font-medium text-white whitespace-nowrap">그림자</span>
          <div class="flex-1 flex justify-end">
            <label for="shadow-toggle" class="relative inline-block w-10 h-5">
              <input type="checkbox" id="shadow-toggle" class="sr-only peer" />
              <!-- 트랙 -->
              <span
                class="block w-full h-full bg-gray-600 rounded-full peer-checked:bg-blue-500 transition-colors"
              ></span>
              <!-- 썸 -->
              <span
                class="absolute top-0.5 left-0.5 w-4 h-4 bg-white rounded-full shadow transition-transform peer-checked:translate-x-5"
              ></span>
            </label>
          </div>
        </div>

        <!-- 그림자 품질 설정: 기본 hidden -->
        <div id="shadow-quality" class="flex items-center space-x-2 mt-2 hidden">
          <span class="text-xs w-32 font-medium text-white whitespace-nowrap">그림자 품질</span>
          <div class="grid grid-cols-3 gap-1 w-60">
            <!-- 낮음 -->
            <div>
              <input
                type="radio"
                name="shadowQuality"
                id="shadow-low"
                value="low"
                class="hidden peer"
              />
              <label
                for="shadow-low"
                class="block w-full h-[24px] flex items-center justify-center text-xs font-medium rounded-lg bg-gray-700 text-gray-300 hover:bg-gray-600 hover:text-white cursor-pointer peer-checked:bg-blue-500 peer-checked:text-white"
              >
                낮음
              </label>
            </div>
            <!-- 보통 -->
            <div>
              <input
                type="radio"
                name="shadowQuality"
                id="shadow-medium"
                value="medium"
                class="hidden peer"
                checked
              />
              <label
                for="shadow-medium"
                class="block w-full h-[24px] flex items-center justify-center text-xs font-medium rounded-lg bg-gray-700 text-gray-300 hover:bg-gray-600 hover:text-white cursor-pointer peer-checked:bg-blue-500 peer-checked:text-white"
              >
                보통
              </label>
            </div>
            <!-- 높음 -->
            <div>
              <input
                type="radio"
                name="shadowQuality"
                id="shadow-high"
                value="high"
                class="hidden peer"
              />
              <label
                for="shadow-high"
                class="block w-full h-[24px] flex items-center justify-center text-xs font-medium rounded-lg bg-gray-700 text-gray-300 hover:bg-gray-600 hover:text-white cursor-pointer peer-checked:bg-blue-500 peer-checked:text-white"
              >
                높음
              </label>
            </div>
          </div>
        </div>

        <hr class="border-t border-gray-500 my-4" />
        <!-- 조명 밝기 -->
        <div class="flex items-center space-x-2 mt-2">
          <span class="text-xs w-32 font-medium text-white whitespace-nowrap">조명 밝기</span>
          <div class="flex items-center space-x-2 w-60 min-w-0">
            <input
              id="light-value"
              type="number"
              value="50"
              min="0"
              max="100"
              class="w-12 h-[24px] px-1 bg-gray-700 text-white text-xs rounded-lg focus:outline-none text-right"
            />
            <input
              id="light-range"
              type="range"
              min="0"
              max="100"
              value="50"
              class="slider"
              style="--percent: 50%"
            />
          </div>
        </div>

        <div class="flex items-center space-x-2 mt-2">
          <span class="text-xs w-32 font-medium text-white whitespace-nowrap">성능 모니터링</span>
          <div class="flex-1 flex items-center justify-end space-x-3">
            <span id="fps-status-indicator" class="text-xs text-gray-400"> </span>
            <label for="fps-toggle" class="relative inline-block w-10 h-5 align-middle">
              <input type="checkbox" id="fps-toggle" class="sr-only peer" />

              <span
                class="block w-full h-full bg-gray-600 rounded-full peer-checked:bg-blue-500 transition-colors"
              ></span>

              <span
                class="absolute top-0.5 left-0.5 w-4 h-4 bg-white rounded-full shadow transition-transform peer-checked:translate-x-5"
              ></span>
            </label>
          </div>
        </div>

        <hr class="border-t border-gray-500 my-4" />
      </div>

      <div id="content3" class="tab-content hidden">
        <h4 class="text-xs font-medium text-white mb-4">바닥 설정</h4>
        <div class="flex items-center space-x-2 mt-2">
          <label
            for="cfg-floor-template-select"
            class="text-xs w-32 font-medium text-white whitespace-nowrap"
            >바닥 템플릿</label
          >
          <div class="w-60">
            <select
              id="cfg-floor-template-select"
              class="h-[24px] px-2 w-full bg-gray-700 text-white text-xs rounded-lg focus:outline-none focus:ring-1 focus:ring-blue-400"
            ></select>
          </div>
        </div>

        <div class="flex items-center space-x-2 mt-2">
          <label for="cfg-floor-width" class="text-xs w-32 font-medium text-white whitespace-nowrap"
            >가로 크기</label
          >
          <div class="w-60">
            <input
              id="cfg-floor-width"
              type="number"
              step="0.1"
              placeholder="가로"
              class="h-[24px] px-2 w-full bg-gray-700 text-white text-xs rounded-lg focus:outline-none focus:ring-1 focus:ring-blue-400"
            />
          </div>
        </div>

        <div class="flex items-center space-x-2 mt-2">
          <label for="cfg-floor-depth" class="text-xs w-32 font-medium text-white whitespace-nowrap"
            >세로 크기</label
          >
          <div class="w-60">
            <input
              id="cfg-floor-depth"
              type="number"
              step="0.1"
              placeholder="세로"
              class="h-[24px] px-2 w-full bg-gray-700 text-white text-xs rounded-lg focus:outline-none focus:ring-1 focus:ring-blue-400"
            />
          </div>
        </div>

        <div class="flex items-center space-x-2 mt-2">
          <label
            for="cfg-floor-thickness"
            class="text-xs w-32 font-medium text-white whitespace-nowrap"
            >두께</label
          >
          <div class="w-60">
            <input
              id="cfg-floor-thickness"
              type="number"
              step="0.01"
              placeholder="두께"
              class="h-[24px] px-2 w-full bg-gray-700 text-white text-xs rounded-lg focus:outline-none focus:ring-1 focus:ring-blue-400"
            />
          </div>
        </div>

        <div class="flex items-center space-x-2 mt-2">
          <label for="cfg-floor-color" class="text-xs w-32 font-medium text-white whitespace-nowrap"
            >색상</label
          >
          <div class="w-60">
            <input
              id="cfg-floor-color"
              type="color"
              class="h-[24px] px-1 w-full bg-gray-700 text-white text-xs rounded-lg border-none cursor-pointer focus:outline-none focus:ring-1 focus:ring-blue-400"
            />
          </div>
        </div>

        <div class="flex items-center space-x-2 mt-2">
          <label
            for="cfg-floor-opacity-value"
            class="text-xs w-32 font-medium text-white whitespace-nowrap"
            >투명도</label
          >
          <div class="flex items-center space-x-2 w-60 min-w-0">
            <input
              id="cfg-floor-opacity-value"
              type="number"
              value="100"
              min="0"
              max="100"
              step="1"
              class="w-12 h-[24px] px-1 bg-gray-700 text-white text-xs rounded-lg focus:outline-none text-right focus:ring-1 focus:ring-blue-400"
            />
            <input
              id="cfg-floor-opacity"
              type="range"
              min="0"
              max="100"
              value="100"
              class="slider"
              style="--percent: 100%"
            />
          </div>
        </div>

        <div class="flex items-center space-x-2 mt-2">
          <label
            for="cfg-floor-shadow"
            class="text-xs w-32 font-medium text-white whitespace-nowrap"
            >그림자 받기</label
          >
          <div class="w-60 flex items-center">
            <input
              id="cfg-floor-shadow"
              type="checkbox"
              class="h-4 w-4 bg-gray-600 border-gray-500 rounded text-blue-400 cursor-pointer focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 focus:ring-offset-gray-800"
            />
          </div>
        </div>

        <div class="flex items-center space-x-2 mt-4">
          <span class="text-xs w-32 font-medium text-white whitespace-nowrap">기준 위치</span>
          <div class="floor-anchor grid grid-cols-3 gap-1 justify-items-center w-60">
            <button
              data-anchor="nw"
              title="North-West"
              class="w-6 h-6 flex items-center justify-center bg-gray-600 rounded hover:bg-yellow-500 text-white"
            >
              ⬉
            </button>
            <button
              data-anchor="n"
              title="North"
              class="w-6 h-6 flex items-center justify-center bg-gray-600 rounded hover:bg-yellow-500 text-white"
            >
              ⬆
            </button>
            <button
              data-anchor="ne"
              title="North-East"
              class="w-6 h-6 flex items-center justify-center bg-gray-600 rounded hover:bg-yellow-500 text-white"
            >
              ↗
            </button>
            <button
              data-anchor="w"
              title="West"
              class="w-6 h-6 flex items-center justify-center bg-gray-600 rounded hover:bg-yellow-500 text-white"
            >
              ⬅
            </button>
            <button
              data-anchor="center"
              title="Center"
              class="w-6 h-6 bg-gray-800 rounded-full text-white flex items-center justify-center"
            >
              ·
            </button>
            <button
              data-anchor="e"
              title="East"
              class="w-6 h-6 flex items-center justify-center bg-gray-600 rounded hover:bg-yellow-500 text-white"
            >
              ➡
            </button>
            <button
              data-anchor="sw"
              title="South-West"
              class="w-6 h-6 flex items-center justify-center bg-gray-600 rounded hover:bg-yellow-500 text-white"
            >
              ↙
            </button>
            <button
              data-anchor="s"
              title="South"
              class="w-6 h-6 flex items-center justify-center bg-gray-600 rounded hover:bg-yellow-500 text-white"
            >
              ⬇
            </button>
            <button
              data-anchor="se"
              title="South-East"
              class="w-6 h-6 flex items-center justify-center bg-gray-600 rounded hover:bg-yellow-500 text-white"
            >
              ↘
            </button>
          </div>
        </div>
      </div>
    </div>

    <button
      id="toggle-edit-mode"
      class="fixed bottom-4 right-4 bg-green-500 text-white py-2 px-3 rounded-lg shadow-lg z-50 focus:outline-none"
    >
      편집 모드 (OFF)
    </button>
    <!-- 하단 중앙: 전체 설정 모달 오픈 아이콘 -->
    <!-- <button
      id="open-general-settings"
      class="fixed bottom-4 left-1/2 transform -translate-x-1/2 bg-gray-800 text-white p-3 rounded-full shadow-lg z-50 hover:bg-gray-700"
      title="전체 설정"
    >
      ⚙️
    </button> -->

    <div
      id="left-panel"
      class="absolute top-4 left-3 bottom-4 w-[230px] bg-gray-800/60 backdrop-blur-md border border-gray-700 rounded-2xl shadow-xl z-50 p-6 flex flex-col space-y-6 overflow-y-auto"
    >
      <!-- 헤더 -->
      <div class="flex items-center justify-between">
        <h2 class="text-lg font-semibold text-white">Rack editor</h2>
        <button class="p-1 hover:bg-gray-700 rounded-lg">
          <svg class="w-5 h-5 text-gray-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M4 6h16M4 12h16M4 18h16"
            />
          </svg>
        </button>
      </div>

      <!-- 탭 -->
      <div class="flex space-x-2">
        <label class="block text-xs text-gray-300">그룹</label>
        <div class="flex space-x-1">
          <select id="cfg-group" class="flex-1 ..."></select>
          <button id="add-group-btn" class="px-2 bg-green-500 rounded text-sm">+</button>
        </div>
      </div>

      <!-- 트리뷰 -->
      <div class="flex-1">
        <ul id="rack-tree" class="list-none text-sm space-y-1 pl-1">
          <!-- JS 로 동적으로 추가 -->
        </ul>
      </div>

      <hr class="border-gray-700" />

      <!-- 랙 구성 설정 -->
      <div class="space-y-4">
        <h4 class="text-lg font-bold text-white">랙 구성 설정</h4>

        <div class="space-y-2">
          <!-- 랙 아이디 -->
          <div class="flex items-center space-x-2">
            <span class="text-xs w-20 font-medium text-white whitespace-nowrap">랙 아이디</span>
            <input
              id="rack-id"
              type="text"
              class="h-[24px] px-2 w-full bg-gray-700 text-white text-xs rounded-lg focus:outline-none focus:ring-1 focus:ring-blue-400"
            />
          </div>

          <!-- 폭 -->
          <div class="flex items-center space-x-2">
            <span class="text-xs w-20 font-medium text-white whitespace-nowrap">폭</span>
            <input
              id="rack-width"
              type="number"
              value="5"
              step="0.1"
              class="h-[24px] px-2 w-full bg-gray-700 text-white text-xs rounded-lg focus:outline-none focus:ring-1 focus:ring-blue-400"
            />
          </div>

          <!-- 깊이 -->
          <div class="flex items-center space-x-2">
            <span class="text-xs w-20 font-medium text-white whitespace-nowrap">깊이</span>
            <input
              id="rack-depth"
              type="number"
              value="1.5"
              step="0.1"
              class="h-[24px] px-2 w-full bg-gray-700 text-white text-xs rounded-lg focus:outline-none focus:ring-1 focus:ring-blue-400"
            />
          </div>

          <!-- 높이 -->
          <div class="flex items-center space-x-2">
            <span class="text-xs w-20 font-medium text-white whitespace-nowrap">높이</span>
            <input
              id="rack-height"
              type="number"
              value="5"
              step="0.1"
              class="h-[24px] px-2 w-full bg-gray-700 text-white text-xs rounded-lg focus:outline-none focus:ring-1 focus:ring-blue-400"
            />
          </div>

          <!-- 단 수 · 셀 수 -->
          <div class="flex items-center space-x-2">
            <span class="text-xs w-20 font-medium text-white whitespace-nowrap">단·셀 수</span>
            <div class="grid grid-cols-2 gap-1 flex-1">
              <input
                id="rack-levels"
                type="number"
                value="5"
                step="1"
                placeholder="단"
                class="h-[24px] px-2 bg-gray-700 text-white text-xs rounded-lg focus:outline-none focus:ring-1 focus:ring-blue-400"
              />
              <input
                id="rack-cells"
                type="number"
                value="4"
                step="1"
                placeholder="셀"
                class="h-[24px] px-2 bg-gray-700 text-white text-xs rounded-lg focus:outline-none focus:ring-1 focus:ring-blue-400"
              />
            </div>
          </div>

          <!-- 회전각도 -->
          <div class="flex items-center space-x-2">
            <span class="text-xs w-20 font-medium text-white whitespace-nowrap">회전각도</span>
            <div class="flex-1 space-y-1">
              <input
                id="rack-rotation"
                type="range"
                min="-180"
                max="180"
                value="0"
                step="5"
                class="w-full"
              />
              <input
                id="rack-rotation-num"
                type="number"
                min="-180"
                max="180"
                value="0"
                step="5"
                class="h-[24px] px-2 w-full bg-gray-700 text-white text-xs rounded-lg focus:outline-none focus:ring-1 focus:ring-blue-400"
              />
            </div>
          </div>

          <!-- 템플릿 선택 -->
          <div class="space-y-1">
            <span class="block text-xs font-medium text-white">템플릿 선택</span>
            <div
              id="template-thumbnails"
              class="mt-2 flex flex-wrap gap-2 max-h-40 overflow-y-auto"
            ></div>
            <input type="hidden" id="selected-template-id" value="default" />
          </div>
        </div>

        <div class="flex space-x-2">
          <button
            id="edit-template"
            class="flex-1 h-10 bg-yellow-500 text-black font-medium rounded-lg hover:bg-yellow-600 focus:outline-none focus:ring-2 focus:ring-yellow-400"
          >
            템플릿 수정
          </button>
          <button
            id="save-template"
            class="flex-1 h-10 bg-purple-600 text-white font-medium rounded-lg hover:bg-purple-700 focus:outline-none focus:ring-2 focus:ring-purple-400"
          >
            템플릿 저장
          </button>
        </div>
        <div class="flex space-x-2">
          <button
            id="add-rack-left-panel"
            class="flex-1 h-10 bg-green-500 text-white font-medium rounded-lg hover:bg-green-600 focus:outline-none focus:ring-2 focus:ring-green-400"
          >
            랙 추가
          </button>
          <button
            id="apply-all-config"
            class="flex-1 h-10 bg-blue-500 text-white font-medium rounded-lg hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-400"
          >
            모두 변경
          </button>
        </div>
      </div>
    </div>

    <!-- 바닥 설정 모달 -->
    <div
      id="floor-edit-modal"
      class="modal bg-white/30 backdrop-blur-xl p-4 outline outline-gray-950/5 rounded-lg text-black z-50"
      style="display: none"
    >
      <div class="flex justify-between items-center border-b pb-2 mb-3">
        <h3 class="text-lg font-bold">바닥 설정</h3>
        <button id="floor-modal-close" class="text-2xl cursor-pointer">×</button>
      </div>
      <div class="flex space-x-4">
        <div class="space-y-2 w-1/2">
          <div>
            <label class="block text-sm">바닥 이름</label>
            <input
              id="floor-name"
              type="text"
              class="w-full p-1 rounded text-black outline outline-gray-200"
              placeholder="바닥 이름 입력"
            />
          </div>
          <div>
            <label class="block text-sm">가로 크기</label>
            <input
              id="floor-width"
              type="number"
              step="1"
              min="10"
              max="500"
              value="100"
              class="w-full p-1 rounded text-black outline outline-gray-200"
            />
          </div>
          <div>
            <label class="block text-sm">세로 크기</label>
            <input
              id="floor-depth"
              type="number"
              step="1"
              min="10"
              max="500"
              value="100"
              class="w-full p-1 rounded text-black outline outline-gray-200"
            />
          </div>
          <div>
            <label class="block text-sm">바닥 색상</label>
            <input id="floor-color" type="color" value="#b0b0b0" class="w-full p-1 rounded" />
          </div>
          <div>
            <label class="block text-sm">바닥 두께</label>
            <input
              id="floor-thickness"
              type="number"
              step="0.1"
              min="0.1"
              max="10"
              value="0.2"
              class="w-full p-1 rounded text-black outline outline-gray-200"
            />
          </div>
          <div>
            <label class="block text-sm">바닥 재질</label>
            <select
              id="floor-material"
              class="w-full p-1 rounded text-black outline outline-gray-200"
            >
              <option value="concrete">콘크리트</option>
              <option value="wood">나무</option>
              <option value="tile">타일</option>
              <option value="custom">사용자 지정 (색상만)</option>
            </select>
          </div>
          <div>
            <label class="block text-sm">바닥 투명도</label>
            <input
              id="floor-opacity"
              type="range"
              min="0"
              max="1"
              step="0.01"
              value="1"
              class="w-full"
            />
          </div>
          <div>
            <label class="block text-sm">바닥 그림자 받기</label>
            <input id="floor-shadow" type="checkbox" checked class="mt-1" />
          </div>
          <div>
            <label class="block text-sm">기본 바닥 템플릿으로 설정</label>
            <input id="set-default-floor" type="checkbox" class="mt-1" />
          </div>
          <div>
            <button id="save-floor-template" class="w-full bg-green-500 py-1 rounded">
              바닥 템플릿 저장
            </button>
          </div>
        </div>
        <div class="w-1/2">
          <canvas
            id="floor-preview-canvas"
            class="w-full h-64 border border-gray-300 rounded"
          ></canvas>
        </div>
      </div>
      <div class="flex justify-end mt-4 space-x-2">
        <button id="save-floor-changes" class="bg-blue-500 py-1 px-3 rounded">적용</button>
        <button id="cancel-floor-changes" class="bg-gray-500 py-1 px-3 rounded">취소</button>
      </div>
    </div>

    <!-- 템플릿 편집 모달 추가 -->
    <div
      id="template-edit-modal"
      class="modal bg-gray-800/90 backdrop-blur-md border border-gray-700 rounded-2xl shadow-xl p-6 text-white z-50"
      style="display: none"
    >
      <div class="flex justify-between items-center border-b border-gray-700 pb-3 mb-4">
        <h3 class="text-xl font-semibold text-white">템플릿 수정</h3>
        <button id="template-modal-close" class="text-3xl text-gray-300 hover:text-white cursor-pointer transition-colors">×</button>
      </div>
      <div class="flex space-x-6">
        <div class="space-y-3 w-1/2">
          <!-- 기존 입력 필드 유지 -->
          <div>
            <label class="block text-sm font-medium text-gray-300 mb-1">템플릿 이름</label>
            <input
              id="edit-template-name"
              type="text"
              class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
            />
          </div>
          <div>
            <label class="block text-sm font-medium text-gray-300 mb-1">기둥 색상</label>
            <input id="edit-pillar-color" type="color" class="w-full h-10 bg-gray-700 border border-gray-600 rounded-lg cursor-pointer" />
          </div>
          <div>
            <label class="block text-sm font-medium text-gray-300 mb-1">선반 색상</label>
            <input id="edit-shelf-color" type="color" class="w-full h-10 bg-gray-700 border border-gray-600 rounded-lg cursor-pointer" />
          </div>
          <div>
            <label class="block text-sm font-medium text-gray-300 mb-1">기둥 두께</label>
            <input
              id="edit-pillar-thickness"
              type="number"
              step="0.01"
              min="0.05"
              max="0.5"
              class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
            />
          </div>
          <div>
            <label class="block text-sm font-medium text-gray-300 mb-1">선반 두께</label>
            <input
              id="edit-shelf-thickness"
              type="number"
              step="0.01"
              min="0.05"
              max="0.5"
              class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
            />
          </div>
          <div class="flex items-center space-x-2">
            <input id="edit-diagonal-supports" type="checkbox" class="w-4 h-4 bg-gray-700 border-gray-600 rounded text-blue-500 focus:ring-2 focus:ring-blue-500" />
            <label class="text-sm font-medium text-gray-300">대각선 보강재 사용</label>
          </div>
          <!-- 새로운 체크박스 추가 -->
          <div class="flex items-center space-x-2">
            <input id="edit-shelf-plate" type="checkbox" class="w-4 h-4 bg-gray-700 border-gray-600 rounded text-blue-500 focus:ring-2 focus:ring-blue-500" />
            <label class="text-sm font-medium text-gray-300">선반 위에 판 추가</label>
          </div>
          <div class="flex items-center space-x-2">
            <input id="edit-top-plate" type="checkbox" class="w-4 h-4 bg-gray-700 border-gray-600 rounded text-blue-500 focus:ring-2 focus:ring-blue-500" />
            <label class="text-sm font-medium text-gray-300">랙 상단에 판 추가</label>
          </div>
          <div class="pt-2">
            <button id="add-new-template" class="w-full bg-green-600 hover:bg-green-700 text-white font-medium py-2 rounded-lg transition-colors focus:outline-none focus:ring-2 focus:ring-green-500">
              새 템플릿 추가
            </button>
          </div>
        </div>
        <div class="w-1/2">
          <canvas id="preview-canvas" class="w-full h-64 bg-gray-900 border border-gray-600 rounded-lg"></canvas>
        </div>
      </div>
      <div class="flex justify-end mt-6 space-x-3">
        <button id="save-template-changes" class="bg-blue-600 hover:bg-blue-700 text-white font-medium py-2 px-6 rounded-lg transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500">저장</button>
        <button id="cancel-template-changes" class="bg-gray-600 hover:bg-gray-700 text-white font-medium py-2 px-6 rounded-lg transition-colors focus:outline-none focus:ring-2 focus:ring-gray-500">취소</button>
      </div>
    </div>

    <!-- 모달 (자재 정보) -->
    <div
      id="material-modal"
      class="modal bg-white/30 backdrop-blur-xl p-4 outline outline-gray-950/5 rounded-lg text-black"
    >
      <div class="flex justify-between items-center border-b pb-2 mb-3">
        <h3 id="modal-title" class="text-lg font-bold">자재 정보</h3>
        <button class="modal-close text-2xl cursor-pointer">×</button>
      </div>
      <div class="space-y-2">
        <div class="flex">
          <div class="font-bold w-24">셀 위치:</div>
          <div id="cell-position">Row 1, Level 2</div>
        </div>
        <div class="flex">
          <div class="font-bold w-24">자재 ID:</div>
          <div id="material-id">MTL-12345</div>
        </div>
        <div class="flex">
          <div class="font-bold w-24">자재명:</div>
          <div id="material-name">스틸 파이프</div>
        </div>
        <div class="flex">
          <div class="font-bold w-24">수량:</div>
          <div id="material-quantity">10 개</div>
        </div>
        <div class="flex">
          <div class="font-bold w-24">입고일:</div>
          <div id="material-date">2023-11-15</div>
        </div>
        <div class="flex">
          <div class="font-bold w-24">상태:</div>
          <div id="material-status">양호</div>
        </div>
      </div>
      <div class="flex justify-end mt-4">
        <button id="close-modal" class="bg-blue-500 py-1 px-3 rounded">닫기</button>
      </div>
    </div>

    <!-- 셀 정보 패널 (left-panel과 동일한 스타일) -->
    <div
      id="cell-info-panel"
      class="fixed right-3 bottom-5 w-[230px] bg-gray-800/90 backdrop-blur-md border border-gray-700 rounded-2xl shadow-xl p-6 hidden z-50"
    >
      <!-- 헤더 -->
      <div class="flex items-center justify-between mb-4">
        <h4 class="text-lg font-semibold text-white flex items-center">
          <svg
            class="w-5 h-5 mr-2 text-blue-400"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
          >
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-3 7h3m-3 4h3m-6-4h.01M9 16h.01"
            />
          </svg>
          셀 정보
        </h4>
        <button
          onclick="document.getElementById('cell-info-panel').classList.add('hidden')"
          class="p-1.5 hover:bg-gray-700 rounded-lg transition-colors"
          aria-label="닫기"
        >
          <svg class="w-5 h-5 text-gray-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M6 18L18 6M6 6l12 12"
            />
          </svg>
        </button>
      </div>

      <!-- 구분선 -->
      <hr class="border-gray-700 mb-4" />

      <!-- 정보 목록 -->
      <div class="space-y-3">
        <div class="flex items-start justify-between">
          <label class="text-sm text-gray-400 min-w-[80px]">셀 ID</label>
          <span id="cell-info-id" class="text-xs font-medium text-white text-right flex-1"></span>
        </div>

        <div class="flex items-start justify-between">
          <label class="text-sm text-gray-400 min-w-[80px]">품목코드</label>
          <span
            id="cell-info-materialId"
            class="text-xs font-medium text-white text-right flex-1"
          ></span>
        </div>

        <div class="flex items-start justify-between">
          <label class="text-sm text-gray-400 min-w-[80px]">이름</label>
          <span id="cell-info-name" class="text-xs font-medium text-white text-right flex-1"></span>
        </div>

        <div class="flex items-start justify-between">
          <label class="text-sm text-gray-400 min-w-[80px]">수량</label>
          <span id="cell-info-qty" class="text-xs font-medium text-white text-right flex-1"></span>
        </div>
      </div>
    </div>

    <!-- 툴팁 -->
    <div id="tooltip" class="tooltip"></div>

    <!-- Three.js 라이브러리 -->
    <script type="importmap">
      {
        "imports": {
          "three": "/static/js/package/build/three.module.js"
        }
      }
    </script>

    <script>
      document.querySelectorAll('#rack-config-panel .tab').forEach((tab) => {
        tab.addEventListener('click', () => {
          // 1) 모든 탭 비활성화
          document.querySelectorAll('#rack-config-panel .tab').forEach((t) => {
            t.classList.remove('text-yellow-300', 'border-b-2', 'border-yellow-300');
            t.classList.add('text-slate-400');
          });
          // 2) 모든 콘텐츠 숨기기
          document.querySelectorAll('#rack-config-panel .tab-content').forEach((c) => {
            c.classList.add('hidden');
          });
          // 3) 클릭된 탭 활성화
          tab.classList.remove('text-slate-400');
          tab.classList.add('text-yellow-300', 'border-b-2', 'border-yellow-300');
          // 4) 해당 콘텐츠 보이기
          const idx = [...document.querySelectorAll('#rack-config-panel .tab')].indexOf(tab) + 1;
          document.getElementById(`content${idx}`).classList.remove('hidden');
        });
      });
    </script>
    <script type="module">
      import { OrbitControls } from '/static/js/package/examples/jsm/controls/OrbitControls.js';
      import { Line2 } from '/static/js/package/examples/jsm/lines/Line2.js';
      import { LineGeometry } from '/static/js/package/examples/jsm/lines/LineGeometry.js';
      import { LineMaterial } from '/static/js/package/examples/jsm/lines/LineMaterial.js';
      import { RoundedBoxGeometry } from '/static/js/package/examples/jsm/geometries/RoundedBoxGeometry.js';
      import {
        CSS2DRenderer,
        CSS2DObject,
      } from '/static/js/package/examples/jsm/renderers/CSS2DRenderer.js';
      import { EdgesGeometry, LineSegments, LineBasicMaterial } from 'three';
      import * as BufferGeometryUtils from '/static/js/package/examples/jsm/utils/BufferGeometryUtils.js';

      import * as THREE from 'three';

      window.onload = async function () {
        await init();
      };

      // ── 그룹 관리용 전역 함수/변수 ──
      function loadGroups() {
        const saved = localStorage.getItem('rackGroups');
        return saved ? JSON.parse(saved) : ['기본'];
      }
      let rackGroups = loadGroups();
      function saveGroups() {
        try {
          localStorage.setItem('rackGroups', JSON.stringify(rackGroups));
        } catch (e) {
          console.error('Failed to save groups to localStorage:', e);
          alert('저장 공간이 부족합니다. 일부 데이터를 삭제해주세요.');
        }
      }

      // localStorage 안전 래퍼 함수
      function safeLocalStorageSet(key, value) {
        try {
          localStorage.setItem(key, value);
          return true;
        } catch (e) {
          console.error(`Failed to save ${key} to localStorage:`, e);
          alert('저장 공간이 부족합니다. 일부 데이터를 삭제해주세요.');
          return false;
        }
      }

      // 입력값 검증 함수 (XSS 방지)
      function sanitizeInput(str) {
        if (typeof str !== 'string') return '';
        return str.replace(/[<>'"&]/g, function (char) {
          const entities = {
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#39;',
            '&': '&amp;',
          };
          return entities[char] || char;
        });
      }

      // localStorage 데이터 검증 함수
      function validateRackConfig(config) {
        return (
          config &&
          typeof config.rackId === 'string' &&
          typeof config.width === 'number' &&
          config.width > 0 &&
          typeof config.depth === 'number' &&
          config.depth > 0 &&
          typeof config.height === 'number' &&
          config.height > 0 &&
          typeof config.levels === 'number' &&
          config.levels > 0 &&
          typeof config.cells === 'number' &&
          config.cells > 0
        );
      }

      // 전역 변수 선언
      let floorAnchor = 'center'; // 기본 기준점
      let scene, camera, renderer, controls;
      let selectedTemplateId = 'default'; // 선택된 템플릿 ID 추적
      let rack;
      let stats;
      let axesHelper;
      let cellMeshes = [];
      let raycaster = new THREE.Raycaster();
      let mouse = new THREE.Vector2();
      let autoRotate = false;
      let rotationSpeed = 0;
      let alignmentHelpers = [];
      let labelRenderer;
      let manualDistance = null;
      let copyBuffer = []; // 복사된 랙들의 userData.config 와 position 저장
      let openGroups = [];
      let mainLight, fillLight, rimLight, spotLight;
      let dragStartX,
        dragStartY,
        isDragging = false;
      const blinkTimers = [];
      const arrowHelpers = [];

      let floorMesh = null; // 바닥 객체
      let gridHelper = null; // 격자 객체
      let floorPreviewRenderer, floorPreviewScene, floorPreviewCamera, floorPreviewMesh;

      let isEditMode = false; // 편집 모드 상태

      let pallets = [];
      let selectedPallets = [];
      let palletDragOffsets = new Map();
      let isPalletDragging = false;
      const RACK_HELPER_COLOR = 0x00ff00; // 연두색

      let measureLine = null;
      let measureLabel = null; // CSS2DRenderer 또는 Sprite 로도 OK
      let measuringPair = []; // [rackA, rackB]

      // 바닥 템플릿 저장소
      let floorTemplates = {};

      // 바닥 텍스처 로드 (필요 시 실제 경로로 변경)
      // const textureLoader = new THREE.TextureLoader();
      // const textures = {
      //   concrete: textureLoader.load('path/to/concrete-texture.jpg'),
      //   wood: textureLoader.load('path/to/wood-texture.jpg'),
      //   tile: textureLoader.load('path/to/tile-texture.jpg')
      // };
      function saveOpenGroups() {
        const tree = document.getElementById('rack-tree');
        // 열린 <details>들 중 data-group 값을 openGroups로
        openGroups = Array.from(tree.querySelectorAll('details'))
          .filter((d) => d.open)
          .map((d) => d.dataset.group);
        safeLocalStorageSet('openGroups', JSON.stringify(openGroups));
      }

      document.querySelectorAll('.floor-anchor button').forEach((btn) => {
        btn.addEventListener('click', () => {
          // 기존 선택 해제
          document
            .querySelectorAll('.floor-anchor button')
            .forEach((b) => b.classList.remove('selected'));
          // 선택한 버튼 강조
          btn.classList.add('selected');
          floorAnchor = btn.dataset.anchor;
          applyFloorSettings(); // 바로 반영
        });
      });

      // 2) 입력값 변화시 실시간 반영
      ['cfg-floor-width', 'cfg-floor-depth', 'cfg-floor-thickness', 'cfg-floor-color'].forEach(
        (id) => {
          document.getElementById(id).addEventListener('input', applyFloorSettings);
        },
      );

      function setEditMode(enabled) {
        if (isEditMode === enabled) return;
        isEditMode = enabled;

        const btn = document.getElementById('toggle-edit-mode');
        btn.textContent = `편집 모드 (${enabled ? 'ON' : 'OFF'})`;
        btn.classList.toggle('bg-green-500', enabled);
        btn.classList.toggle('bg-gray-600', !enabled);

        // 편집 전용 헬퍼들
        const editHelpers = [gridHelper, axesHelper, ...alignmentHelpers];
        editHelpers.forEach((h) => {
          if (h) h.visible = enabled;
        });

        // 드래그 관련 이벤트 리스너 (뷰어 모드일 때 완전히 제거 → 메모리/CPU 절감)
        const canvas = renderer.domElement;
        if (enabled) {
          canvas.style.cursor = 'move';
          // 드래그 시작/끝 이벤트 다시 등록 (이미 등록돼 있으면 무시)
        } else {
          canvas.style.cursor = 'default';
          clearSelectedRacks();
          clearMeasurementVisuals();
          hideRackToolbar();
        }

        // 랙/파렛트 드래그 가능 여부 강제 설정
        racks.forEach((r) => (r.userData.draggable = enabled));
        pallets.forEach((p) => (p.userData.draggable = enabled));

        // 라벨도 뷰어 모드에선 필요 없으면 꺼도 됨 (선택사항)
        // labelSprites.forEach(s => s.visible = enabled ? labelsVisible : false);
      }

      // 3) 바닥 생성/업데이트 함수 수정
      function applyFloorSettings() {
        // Guard: floorMesh가 초기화되지 않았으면 리턴
        if (!floorMesh || !floorMesh.geometry) {
          console.warn('floorMesh is not initialized yet');
          return;
        }

        // 1) 새 크기 읽기
        const newW = parseFloat(document.getElementById('cfg-floor-width').value) || 100;
        const newD = parseFloat(document.getElementById('cfg-floor-depth').value) || 100;
        const newT = parseFloat(document.getElementById('cfg-floor-thickness').value) || 0.5;
        const color = parseInt(
          document.getElementById('cfg-floor-color').value.replace('#', ''),
          16,
        );

        // 2) 이전 크기·위치 읽기
        const oldGeom = floorMesh.geometry.parameters;
        const oldW = oldGeom.width;
        const oldD = oldGeom.depth;
        const oldX = floorMesh.position.x;
        const oldZ = floorMesh.position.z;

        // 3) 크기 변화량 계산
        const deltaW = newW - oldW;
        const deltaD = newD - oldD;

        // 4) 앵커별 부호 설정
        const signMap = {
          center: [0, 0],
          n: [0, -1],
          s: [0, +1],
          w: [+1, 0],
          e: [-1, 0],
          nw: [+1, -1],
          ne: [-1, -1],
          sw: [+1, +1],
          se: [-1, +1],
        };
        const [sx, sz] = signMap[floorAnchor] || [0, 0];

        // 5) 기존 메시 제거
        scene.remove(floorMesh);
        floorMesh.geometry.dispose();
        floorMesh.material.dispose();

        // 6) 새 메시 생성
        const geom = new THREE.BoxGeometry(newW, newT, newD);
        const mat = new THREE.MeshStandardMaterial({
          color: color,
          roughness: 0.8,
          metalness: 0.2,
        });
        floorMesh = new THREE.Mesh(geom, mat);
        floorMesh.receiveShadow = true;
        floorMesh.castShadow = true;

        // 7) 위치 보정: oldPos + (delta/2)*sign
        floorMesh.position.x = oldX + (deltaW / 2) * sx;
        floorMesh.position.y = newT / 2;
        floorMesh.position.z = oldZ + (deltaD / 2) * sz;

        // 8) 씬에 추가 및 렌더
        scene.add(floorMesh);
        renderer.render(scene, camera);

        // 9) 로컬스토리지에 업데이트된 값 저장 (선택한 템플릿에 덮어쓰기)
        const tplId = document.getElementById('cfg-floor-template-select').value;
        if (floorTemplates[tplId]) {
          floorTemplates[tplId] = {
            ...floorTemplates[tplId],
            width: newW,
            depth: newD,
            thickness: newT,
            color: color,
            // materialType, opacity, receiveShadow 등은 그대로 유지됩니다
          };
          localStorage.setItem('floorTemplates', JSON.stringify(floorTemplates));
        }
      }

      // 미리보기 캔버스 초기화
      function initFloorPreviewCanvas() {
        const canvas = document.getElementById('floor-preview-canvas');
        // 캔버스 크기 명시적으로 설정
        canvas.width = canvas.clientWidth;
        canvas.height = canvas.clientHeight;

        floorPreviewRenderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        floorPreviewRenderer.setSize(canvas.clientWidth, canvas.clientHeight);
        floorPreviewRenderer.setClearColor(0xdddddd); // 배경색 설정

        floorPreviewScene = new THREE.Scene();
        floorPreviewCamera = new THREE.PerspectiveCamera(
          45,
          canvas.clientWidth / canvas.clientHeight,
          0.1,
          1000,
        );
        floorPreviewCamera.position.set(0, 5, 5);
        floorPreviewCamera.lookAt(0, 0, 0);

        // 조명 추가
        const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
        floorPreviewScene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 5, 5);
        floorPreviewScene.add(directionalLight);

        // 초기 바닥 추가
        updateFloorPreview();
      }

      let hoveredCell = null;
      const tooltip = document.getElementById('tooltip');
      const modal = document.getElementById('material-modal');
      const highlightModeSelect = document.getElementById('highlight-mode') || {
        value: 'status' /* 기본 모드 */,
      };
      const rotationSpeedInput = document.getElementById('rotation-speed');
      const resetCameraBtn = document.getElementById('reset-camera');
      const lightIntensityInput = document.getElementById('light-intensity');
      const toggleLabelsBtn = document.getElementById('toggle-labels');

      // 편집 모드 관련 변수
      let editMode = false;
      const toggleEditModeBtn = document.getElementById('toggle-edit-mode');

      // 랙 선택 관련 변수 (단일 및 다중 선택)
      let selectedRack = null;
      let selectedRackHelper = null;
      let selectedRacks = [];
      let selectedRackHelpers = [];
      // 다중 선택 드래그 관련 변수 (각 랙마다 오프셋 저장)
      let rackDragOffsets = new Map();

      // 모든 랙 저장 배열
      let racks = [];

      // 라벨 관련 변수
      let labelsVisible = !isEditMode;
      let labelSprites = [];

      // Material Pool - 템플릿별 재질 재사용
      const materialPools = {
        rack: new Map(), // 랙 구조물 재질 (템플릿별)
        cell: null, // 셀 관련 재질 (전역 공유)
      };

      // 전역 자재 데이터 (예시)
      let rackData = { cells: [] };

      // 랙 드래그 관련 변수 (바닥 기준 x,z 이동)
      let isRackDragging = false;
      let rackDragOffset = new THREE.Vector3();
      let dragPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);

      // 전역 변수
      let defaultSettings = {
        defaultFloorTemplateId: null,
        // defaultRackTemplateId: null
      };

      // 툴바 관련 전역 변수
      let rackToolbar = null;
      let toolbarCloseBtn = null;
      let toolbarApplyBtn = null;
      let toolbarDeleteBtn = null;
      let toolbarInputs = null;

      let selectedPalletHelpers = []; // 선택 시 헬퍼 관리 (옵션)

      // 랙 템플릿 수정 전역 변수
      let previewScene, previewCamera, previewRenderer, previewRack, previewControls;
      let rackTemplates = {};

      // 로컬스토리지에서 템플릿 로드
      function loadTemplatesFromStorage() {
        const storedTemplates = localStorage.getItem('rackTemplates');
        if (storedTemplates) {
          rackTemplates = JSON.parse(storedTemplates);
        } else {
          rackTemplates = {
            default: {
              name: '기본 템플릿',
              pillar: { color: 0x001cff, metalness: 0.4, roughness: 0.4, thickness: 0.1 },
              shelf: { color: 0xff0000, metalness: 0.2, roughness: 0.6, thickness: 0.1 },
              supports: { enabled: true, diagonal: true },
              shelfPlate: false,
              topPlate: false,
            },
          };
        }

        // 변경된 템플릿을 로컬스토리지에 다시 저장
        localStorage.setItem('rackTemplates', JSON.stringify(rackTemplates));
      }

      // 템플릿 드롭다운 채우기 함수 (먼저 정의)
      function populateTemplateDropdown() {
        const select = document.getElementById('template-select');
        if (!select) {
          console.error('template-select element not found');
          return;
        }
        select.innerHTML = '';
        Object.keys(rackTemplates).forEach((templateId) => {
          const option = document.createElement('option');
          option.value = templateId;
          option.textContent = rackTemplates[templateId].name;
          select.appendChild(option);
        });
      }

      // 템플릿 이름 중복 체크
      function isTemplateNameDuplicate(name, excludeTemplateId = null) {
        return Object.entries(rackTemplates).some(([id, template]) => {
          if (excludeTemplateId && id === excludeTemplateId) return false; // 수정 중인 템플릿 제외
          return template.name.toLowerCase() === name.toLowerCase();
        });
      }

      // 미리보기 캔버스 초기화
      function initPreviewCanvas() {
        const canvas = document.getElementById('preview-canvas');
        previewScene = new THREE.Scene();
        previewScene.background = new THREE.Color(0x1f2937); // 다크 그레이 배경

        previewCamera = new THREE.PerspectiveCamera(45, canvas.width / canvas.height, 0.1, 1000);
        previewCamera.position.set(5, 5, 5);
        previewCamera.lookAt(0, 0, 0);

        previewRenderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
        previewRenderer.setSize(canvas.width, canvas.height);
        previewRenderer.shadowMap.enabled = false; // 미리보기에서는 그림자 비활성화로 성능 향상

        // 조명 강도 대폭 증가 (색상이 더 밝게 보이도록)
        const ambientLight = new THREE.AmbientLight(0xffffff, 2.5); // 강도를 0.8에서 2.5로 대폭 증가
        previewScene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 2.0); // 강도를 1.0에서 2.0으로 증가
        directionalLight.position.set(5, 5, 5);
        directionalLight.castShadow = false; // 그림자 비활성화
        previewScene.add(directionalLight);

        // 추가 조명: PointLight 삽입 (더 밝게)
        const pointLight = new THREE.PointLight(0xffffff, 1.5, 100); // 강도 0.5에서 1.5로 증가
        pointLight.position.set(0, 5, 0); // 랙 상단에 위치
        previewScene.add(pointLight);

        // 반대편에서도 조명 추가 (균일한 밝기)
        const fillLight = new THREE.DirectionalLight(0xffffff, 1.5);
        fillLight.position.set(-5, 3, -5);
        previewScene.add(fillLight);

        // OrbitControls 추가
        previewControls = new OrbitControls(previewCamera, previewRenderer.domElement);
        previewControls.enableDamping = true;
        previewControls.dampingFactor = 0.05;
        previewControls.screenSpacePanning = false;
        previewControls.minDistance = 2;
        previewControls.maxDistance = 10;

        // 애니메이션 루프
        let previewAnimationId = null;
        function animate() {
          previewAnimationId = requestAnimationFrame(animate);
          previewControls.update();
          previewRenderer.render(previewScene, previewCamera);
        }
        animate();

        // 미리보기 애니메이션 정리 함수
        window.stopPreviewAnimation = function () {
          if (previewAnimationId) {
            cancelAnimationFrame(previewAnimationId);
            previewAnimationId = null;
          }
        };
      }

      // 템플릿 미리보기 업데이트
      function updatePreviewRack() {
        if (previewRack) {
          previewScene.remove(previewRack);
          previewRack.traverse((child) => {
            if (child.geometry) child.geometry.dispose();
            if (child.material) child.material.dispose();
          });
          // preview 랙의 유령 셀과 라벨 정리
          cellMeshes = cellMeshes.filter((mesh) => mesh.userData.rackId !== 'preview');
          labelSprites = labelSprites.filter((sprite) => sprite.userData.rackId !== 'preview');
        }

        const pillarColor = parseInt(
          document.getElementById('edit-pillar-color').value.replace('#', ''),
          16,
        );
        const shelfColor = parseInt(
          document.getElementById('edit-shelf-color').value.replace('#', ''),
          16,
        );
        const pillarThickness =
          parseFloat(document.getElementById('edit-pillar-thickness').value) || 0.1;
        const shelfThickness =
          parseFloat(document.getElementById('edit-shelf-thickness').value) || 0.1;
        const diagonalSupports = document.getElementById('edit-diagonal-supports').checked;
        const shelfPlate = document.getElementById('edit-shelf-plate').checked;
        const topPlate = document.getElementById('edit-top-plate').checked;

        const tempTemplate = {
          pillar: {
            color: pillarColor,
            metalness: 0.4,
            roughness: 0.4,
            thickness: pillarThickness,
          },
          shelf: { color: shelfColor, metalness: 0.2, roughness: 0.6, thickness: shelfThickness },
          supports: { enabled: true, diagonal: diagonalSupports },
          shelfPlate: shelfPlate,
          topPlate: topPlate,
        };

        previewRack = createRack('preview', 2, 1, 1, 2, 2, null, false, 'temp', tempTemplate);
        previewScene.add(previewRack);
        previewRenderer.render(previewScene, previewCamera);
      }

      function deleteSelectedRacks() {
        if (selectedRacks.length === 0) return;

        // 삭제할 랙 ID 목록 수집
        const rackIdsToDelete = selectedRacks.map((rack) => rack.userData.rackId);

        // 선택된 랙과 관련된 리소스 정리
        selectedRacks.forEach((rackObj) => {
          // 1. 씬에서 랙 제거
          scene.remove(rackObj);

          // 2. 셀 메시와 라벨 정리
          cleanRackElements(rackObj);

          // 3. 개별 로컬 스토리지 항목 삭제
          localStorage.removeItem('rackConfig_' + rackObj.userData.rackId);

          // 4. 리소스 해제 (메모리 정리)
          disposeRackResources(rackObj);
        });

        // 5. racks 배열에서 삭제된 랙 제거 및 유효한 객체만 남김 (Set 사용으로 성능 개선)
        const deleteSet = new Set(rackIdsToDelete);
        racks = racks.filter(
          (rack) => rack?.userData?.rackId && !deleteSet.has(rack.userData.rackId),
        );

        // 6. 선택된 랙 및 헬퍼 초기화
        clearSelectedRacks();
        clearMeasurementVisuals();

        // 7. UI 초기화
        document.getElementById('rack-id').value = '';

        // 8. allRackConfigs에서 삭제된 랙 제거 후 저장
        const configArrayStr = localStorage.getItem('allRackConfigs');
        if (configArrayStr) {
          let configArray = JSON.parse(configArrayStr);
          configArray = configArray.filter((config) => !rackIdsToDelete.includes(config.rackId));
          localStorage.setItem('allRackConfigs', JSON.stringify(configArray));
          console.log('Updated allRackConfigs after deletion:', configArray);
        }

        // 9. 툴팁 숨기기
        tooltip.style.display = 'none';

        console.log('Deleted selected racks, helpers, cells, and updated localStorage.');
      }

      // onMouseMove 보다 위, 또는 init() 직전에 정의
      function createLabelElement(initialText) {
        const container = document.createElement('div');
        container.className = 'distance-label';
        container.style.pointerEvents = 'auto';
        container.style.cursor = 'pointer';

        const span = document.createElement('span');
        span.textContent = initialText + 'm';
        container.appendChild(span);

        container.addEventListener('click', (e) => {
          e.stopPropagation();

          // 현재 span 에서 숫자만 추출
          const currentText = span.textContent.replace('m', '');
          const num = parseFloat(currentText) || 0;

          // input 생성
          const input = document.createElement('input');
          input.type = 'number';
          input.step = '0.01';
          input.value = num.toFixed(2);
          input.style.width = '50px';
          input.style.color = 'black';

          // container 내용 교체
          container.innerHTML = '';
          container.appendChild(input);

          // 클릭/드래그 이벤트 캡처 방지
          input.addEventListener('mousedown', (ev) => ev.stopPropagation());
          input.addEventListener('click', (ev) => ev.stopPropagation());
          input.addEventListener('dblclick', (ev) => {
            ev.stopPropagation();
            ev.target.select(); // 더블클릭 시 전체 선택
          });
          input.addEventListener('focus', (ev) => ev.target.select()); // 포커스 시 전체 선택

          // 포커스 + 즉시 전체 선택
          input.focus();
          input.select();

          function apply() {
            const v = parseFloat(input.value);
            const newVal = isNaN(v) ? num : v;
            updateDistance(newVal);

            // 다시 span 으로 복구
            span.textContent = newVal.toFixed(2) + 'm';
            container.innerHTML = '';
            container.appendChild(span);
          }

          input.addEventListener('keydown', (ev) => {
            if (ev.key === 'Enter') apply();
          });
          input.addEventListener('blur', apply);
        });

        return container;
      }

      function updateDistance(newD) {
        manualDistance = newD;
        if (measuringPair.length !== 2 || !measureLine) return;
        const [rackA, rackB] = measuringPair;

        // 1) rack 간 방향·반치수·gap 계산
        const dir = new THREE.Vector3().subVectors(rackB.position, rackA.position).normalize();
        const { halfX: hxA, halfZ: hzA } = getWorldHalfExtents(rackA);
        const { halfX: hxB, halfZ: hzB } = getWorldHalfExtents(rackB);
        const gap = 0.2; // 원하는 고정 여유(m)

        // support 거리 (면 방향에 따라 자동 계산)
        const supportDistA = Math.abs(dir.x) * hxA + Math.abs(dir.z) * hzA;
        const supportDistB = Math.abs(dir.x) * hxB + Math.abs(dir.z) * hzB;

        // 2) p1/p2 재계산 (수동 입력값 newD 적용)
        const centerDist = newD + supportDistA + supportDistB;
        // rackA를 이동
        rackA.position.copy(rackB.position.clone().sub(dir.clone().multiplyScalar(centerDist)));

        // p1, p2: 랙 edge + gap
        const p1 = rackA.position.clone().add(dir.clone().multiplyScalar(supportDistA + gap));
        const p2 = rackB.position.clone().add(dir.clone().multiplyScalar(-(supportDistB + gap)));

        // 3) 선 업데이트
        measureLine.geometry.setFromPoints([p1, p2]);

        // 4) 라벨 위치·텍스트 업데이트
        const distText = newD.toFixed(2) + 'm';
        const mid = p1.clone().lerp(p2, 0.5);
        if (measureLabel) {
          const span = measureLabel.element.querySelector('span');
          if (span) span.textContent = distText;
          else measureLabel.element.textContent = distText;
          measureLabel.position.copy(mid);
        }

        // 5) 화살표 위치 업데이트
        // 기존 화살표 제거
        arrowHelpers.forEach((a) => scene.remove(a));
        arrowHelpers.length = 0;

        const headLength = 0.3,
          headWidth = 0.2;
        // A 쪽: B→A 방향으로
        const arrowA = new THREE.ArrowHelper(
          dir.clone().negate(),
          p1,
          0,
          0xff8800,
          headLength,
          headWidth,
        );
        // B 쪽: A→B 방향으로
        const arrowB = new THREE.ArrowHelper(dir, p2, 0, 0xff8800, headLength, headWidth);
        scene.add(arrowA, arrowB);
        arrowHelpers.push(arrowA, arrowB);
      }

      async function init() {
        stats = new Stats();
        stats.showPanel(0); // 0: fps, 1: ms, 2: mb, 3+: custom
        stats.dom.style.display = 'none'; // 초기 상태 숨김
        document.body.appendChild(stats.dom);

        scene = new THREE.Scene();

        // 1) 캔버스에 방사형 그라데이션 그리기
        const size = 512;
        const bgCanvas = document.createElement('canvas');
        bgCanvas.width = size;
        bgCanvas.height = size;
        const ctx = bgCanvas.getContext('2d');

        // 가운데 좌표, 내부 반지름(r0)을 키워줍니다 (예: size*0.1)
        // 외부 반지름(r1)은 그대로 size/2
        const cx = size / 2,
          cy = size / 2;
        const r0 = size * 0.05; // 내부 밝은 영역 반지름
        const r1 = size / 2; // 전체 그라데이션 반지름

        const grad = ctx.createRadialGradient(cx, cy, r0, cx, cy, r1);

        // — 색상정지점도 조금 조정 —
        // 0.0 ~ 0.2 구간은 완전 밝고,
        // 0.2 ~ 0.5 사이에 중간톤으로 넘어가며,
        // 1.0 에 가까워질수록 깊은 다크로 전환
        grad.addColorStop(0.0, '#2E3A50'); // 완전 중앙
        grad.addColorStop(0.2, '#2E3A50'); // r0 기준 근처까지 동일 밝기
        grad.addColorStop(0.5, '#1F2738'); // 중간톤
        grad.addColorStop(1.0, '#0A0E12'); // 가장자리

        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, size, size);

        // 2) THREE.CanvasTexture 로 텍스처 만들어 배경에 적용
        const bgTexture = new THREE.CanvasTexture(bgCanvas);
        bgTexture.minFilter = THREE.LinearFilter;
        scene.background = bgTexture;

        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(10, 50, 5);

        renderer = new THREE.WebGLRenderer({
          antialias: true,
          powerPreference: 'high-performance',
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // 2배 이상은 의미 없음
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;

        renderer.shadowMap.enabled = false; //초기에는 그림자 비활성화
        renderer.shadowMap.type = THREE.PCFShadowMap; //그림자 품질 기본값: 보통
        renderer.outputEncoding = THREE.sRGBEncoding;

        const container = document.getElementById('canvas-container');
        container.appendChild(renderer.domElement);

        labelRenderer = new CSS2DRenderer();
        labelRenderer.setSize(window.innerWidth, window.innerHeight);
        labelRenderer.domElement.style.position = 'absolute';
        labelRenderer.domElement.style.top = '0';
        // → CSS2D 컨테이너 자체는 마우스 이벤트를 차단하지 않도록
        labelRenderer.domElement.style.pointerEvents = 'none';

        // 3) 순서대로 #canvas-container에 붙이기
        container.appendChild(labelRenderer.domElement);

        controls = new OrbitControls(camera, renderer.domElement);

        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI / 1.5;

        setupLights();
        // updateLightIntensity();

        // 바닥 템플릿 로드
        loadFloorTemplatesFromStorage();

        // 기본 설정 로드
        loadDefaultSettings();

        const shadowToggle = document.getElementById('shadow-toggle');
        const shadowQuality = document.getElementById('shadow-quality');

        // 페이지 로드 시 상태 반영
        shadowQuality.classList.toggle('hidden', !shadowToggle.checked);

        // 토글 변경 시
        shadowToggle.addEventListener('change', (e) => {
          // shadow-toggle 체크된 경우 품질 설정 보이기, 아니면 숨기기
          shadowQuality.classList.toggle('hidden', !e.target.checked);
        });
        shadowToggle.addEventListener('change', (e) => {
          const enabled = e.target.checked;

          // 1) 렌더러 자체의 그림자 활성화/비활성화
          renderer.shadowMap.enabled = enabled;

          // 2) 주요 라이트의 그림자 설정
          mainLight.castShadow = enabled;
          if (spotLight) spotLight.castShadow = enabled;
          if (fillLight) fillLight.castShadow = enabled;
          if (rimLight) rimLight.castShadow = enabled;

          // 3) 씬의 모든 메시(mesh)에 대해 cast/receiveShadow 설정
          scene.traverse((obj) => {
            if (obj.isMesh) {
              // 각 메시의 역할에 따라 적절하게 그림자 설정
              if (obj.name === 'pillarStructure') {
                obj.castShadow = enabled;
                obj.receiveShadow = false;
              } else if (obj.name === 'plateStructure') {
                obj.castShadow = false;
                obj.receiveShadow = enabled;
              } else if (obj.name === 'shelfStructure') {
                obj.castShadow = false;
                obj.receiveShadow = false;
              } else if (obj === floorMesh) {
                obj.castShadow = false;
                obj.receiveShadow = enabled;
              } else {
                // 기타 메시(파렛트 등)
                obj.castShadow = enabled;
                obj.receiveShadow = enabled;
              }
            }
          });
        });

        shadowToggle.checked = false; // 초기에는 그림자 비활성화
        shadowToggle.dispatchEvent(new Event('change'));

        // 그림자 품질 설정 이벤트 핸들러
        const shadowQualityRadios = document.querySelectorAll('input[name="shadowQuality"]');
        shadowQualityRadios.forEach((radio) => {
          radio.addEventListener('change', (e) => {
            const quality = e.target.value;
            let mapSize = 2048; // 기본값

            // 그림자 맵 타입 및 해상도 변경
            switch(quality) {
              case 'low':
                renderer.shadowMap.type = THREE.BasicShadowMap;
                mapSize = 1024;
                break;
              case 'medium':
                renderer.shadowMap.type = THREE.PCFShadowMap;
                mapSize = 2048;
                break;
              case 'high':
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                mapSize = 4096;
                break;
            }

            // 모든 라이트의 그림자 맵 크기 변경
            if (mainLight && mainLight.shadow) {
              mainLight.shadow.mapSize.set(mapSize, mapSize);
              mainLight.shadow.map?.dispose(); // 기존 그림자 맵 해제
              mainLight.shadow.map = null;
            }
            if (spotLight && spotLight.shadow) {
              spotLight.shadow.mapSize.set(mapSize, mapSize);
              spotLight.shadow.map?.dispose();
              spotLight.shadow.map = null;
            }
            if (fillLight && fillLight.shadow) {
              fillLight.shadow.mapSize.set(mapSize, mapSize);
              fillLight.shadow.map?.dispose();
              fillLight.shadow.map = null;
            }
            if (rimLight && rimLight.shadow) {
              rimLight.shadow.mapSize.set(mapSize, mapSize);
              rimLight.shadow.map?.dispose();
              rimLight.shadow.map = null;
            }

            // 그림자가 현재 활성화되어 있는 경우에만 재설정
            const shadowToggle = document.getElementById('shadow-toggle');
            if (shadowToggle && shadowToggle.checked) {
              // 그림자를 잠깐 껐다가 다시 켜서 변경사항 즉시 반영
              renderer.shadowMap.enabled = false;

              // 다음 프레임에서 그림자 다시 활성화
              setTimeout(() => {
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.needsUpdate = true;

                // 모든 메시의 그림자 설정 재적용
                scene.traverse((obj) => {
                  if (obj.isMesh) {
                    if (obj.name === 'pillarStructure') {
                      obj.castShadow = true;
                      obj.receiveShadow = false;
                    } else if (obj.name === 'plateStructure') {
                      obj.castShadow = false;
                      obj.receiveShadow = true;
                    } else if (obj.name === 'shelfStructure') {
                      obj.castShadow = false;
                      obj.receiveShadow = false;
                    } else if (obj === floorMesh) {
                      obj.castShadow = false;
                      obj.receiveShadow = true;
                    } else {
                      obj.castShadow = true;
                      obj.receiveShadow = true;
                    }
                  }
                });

                // 라이트 그림자 재활성화
                mainLight.castShadow = true;
                if (spotLight) spotLight.castShadow = true;
                if (fillLight) fillLight.castShadow = true;
                if (rimLight) rimLight.castShadow = true;
              }, 10);
            } else {
              // 그림자가 비활성화 상태면 needsUpdate만 설정
              renderer.shadowMap.needsUpdate = true;
            }
          });
        });

        // 초기 그림자 품질 설정 (보통)
        const mediumQuality = document.getElementById('shadow-medium');
        if (mediumQuality && mediumQuality.checked) {
          renderer.shadowMap.type = THREE.PCFShadowMap;
        }

        // 기본 바닥 템플릿이 없으면 생성
        if (
          !defaultSettings.defaultFloorTemplateId ||
          !floorTemplates[defaultSettings.defaultFloorTemplateId]
        ) {
          const defaultTemplateId = `floor-${Date.now()}`;
          floorTemplates[defaultTemplateId] = {
            name: '기본 바닥',
            width: 50,
            depth: 50,
            color: 0xb0b0b0,
            thickness: 0.5, // 기본 두께
            materialType: 'custom',
            opacity: 1,
            receiveShadow: true,
          };
          localStorage.setItem('floorTemplates', JSON.stringify(floorTemplates));
          defaultSettings.defaultFloorTemplateId = defaultTemplateId;
          saveDefaultSettings();
        }

        // 초기 바닥 생성
        const defaultFloorTemplateId = defaultSettings.defaultFloorTemplateId;
        let floorConfig = { isEditMode };

        if (defaultFloorTemplateId && floorTemplates[defaultFloorTemplateId]) {
          floorConfig = { ...floorTemplates[defaultFloorTemplateId], isEditMode };
        }

        createFloor(floorConfig); // 초기 바닥 생성

        // 로컬스토리지에서 템플릿 로드
        loadTemplatesFromStorage();

        // 템플릿 썸네일 초기화
        populateTemplateThumbnails();

        // 우측 패널 입력값 변화 감지 (폭·깊이·…·회전 + 그룹)
        const cfgFields = [
          'cfg-rack-id',
          'cfg-width',
          'cfg-depth',
          'cfg-height',
          'cfg-levels',
          'cfg-cells',
          'cfg-rotation-value',
        ];
        cfgFields.forEach((id) => {
          const el = document.getElementById(id);
          if (!el) return;
          el.addEventListener('input', () => applyCfgPanelConfig());
        });

        // 그룹 셀렉트만 변경됐을 때도 동작하도록 별도 change 핸들러 추가
        const cfgGroupSelect = document.getElementById('cfg-group-select');
        cfgGroupSelect.addEventListener('change', () => {
          if (selectedRacks.length !== 1) return;
          const rackObj = selectedRacks[0];
          // 바로 userData.config.group 만 바꿔 주고
          rackObj.userData.config.group = cfgGroupSelect.value;
          // 트리뷰를 포함해서 저장 및 리렌더링
          saveAllRackConfigs();
        });

        // 2) ID 입력란도 활성화하고, blur 시 중복 검사 후 변경
        const idInput = document.getElementById('cfg-rack-id');
        idInput.disabled = false;
        idInput.addEventListener('blur', () => {
          if (selectedRacks.length !== 1) return;
          const rackObj = selectedRacks[0];
          const oldId = rackObj.userData.rackId;
          const newId = idInput.value.trim();

          // 빈 문자열 검사
          if (!newId) {
            alert('랙 아이디를 비울 수 없습니다.');
            idInput.value = oldId;
            return;
          }
          // 중복 검사
          const exists = racks.some((r) => r.userData.rackId === newId && r !== rackObj);
          if (exists) {
            alert(`아이디 "${newId}"는 이미 사용 중입니다.`);
            idInput.value = oldId;
            return;
          }

          // 1) rackObj.userData만 업데이트
          rackObj.userData.rackId = newId;
          rackObj.userData.config.rackId = newId;

          // 2) 관련된 셀(mesh)과 라벨(sprite)의 userData.rackId도 갱신
          cellMeshes.forEach((mesh) => {
            if (mesh.userData.rackId === oldId) mesh.userData.rackId = newId;
          });
          labelSprites.forEach((sprite) => {
            if (sprite.userData && sprite.userData.rackId === oldId) {
              sprite.userData.rackId = newId;
            }
          });

          // 3) 로컬스토리지 저장 및 UI 트리 갱신
          saveAllRackConfigs();
          loadRackTree();

          // 4) 오른쪽 패널과 툴바에도 반영
          idInput.value = newId;
          // showRackToolbar(rackObj);
        });

        const cfgPanel = document.getElementById('rack-config-panel');
        if (cfgPanel) {
          ['mousedown', 'click'].forEach((evt) => {
            cfgPanel.addEventListener(evt, (e) => e.stopPropagation());
          });
        }

        // 저장된 랙 로드 (데이터 검증 포함)
        const savedConfigs = (JSON.parse(localStorage.getItem('allRackConfigs')) || []).filter(
          validateRackConfig,
        );
        for (const config of savedConfigs) {
          const rack = createRack(
            config.rackId,
            config.width,
            config.depth,
            config.height,
            config.levels,
            config.cells,
            null,
            false,
            config.templateId,
          );
          rack.position.set(config.posX, config.posY, config.posZ);
          rack.rotation.y = THREE.MathUtils.degToRad(config.rotation);
          rack.userData.config.rotation = config.rotation;

          rack.userData.config.group = config.group || '기본';
          rack.visible = config.visible !== false;

          await loadDataAndMapForRack(rack);
        }

        const savedPalletConfigs = JSON.parse(localStorage.getItem('allPalletConfigs')) || [];
        if (savedPalletConfigs.length > 0) {
          for (const config of savedPalletConfigs) {
            // 'preview'나 'temp' 파렛트를 제외하고 로드
            if (config.palletId !== 'preview' && config.palletId !== 'temp') {
              const pallet = createPallet(config.palletId, config.templateId);
              pallet.position.set(config.posX, config.posY, config.posZ);
              pallet.rotation.y = THREE.MathUtils.degToRad(config.rotation);
              pallets.push(pallet);
              scene.add(pallet);
            }
          }
        }

        document.getElementById('edit-template').addEventListener('click', () => {
          showTemplateEditModal(selectedTemplateId);
        });

        window.addEventListener('resize', onWindowResize);
        window.addEventListener('click', (e) => {
          if (isDragging) {
            // 드래그 후 release → 클릭 무시
            isDragging = false;
            return;
          }
          onMouseClick(e);
        });

        window.addEventListener('mousemove', (e) => {
          if (Math.abs(e.clientX - dragStartX) > 5 || Math.abs(e.clientY - dragStartY) > 5) {
            isDragging = true;
          }
          onMouseMove(e);
        });

        // highlightModeSelect.addEventListener('change', updateHighlightMode);
        // rotationSpeedInput.addEventListener('input', updateRotationSpeed);
        // lightIntensityInput.addEventListener('input', updateLightIntensity);
        // shadowQualitySelect.addEventListener('change', updateShadowQuality);
        // toggleLabelsBtn.addEventListener('click', toggleLabels);

        toggleEditModeBtn.addEventListener('click', toggleEditMode);

        document.getElementById('rack-rotation').addEventListener('input', function () {
          document.getElementById('rack-rotation-num').value = this.value;
        });
        document.getElementById('rack-rotation-num').addEventListener('input', function () {
          document.getElementById('rack-rotation').value = this.value;
        });

        window.addEventListener(
          'keydown',
          function (event) {
            if (event.key === 'Delete' || event.key === 'Del') {
              deleteSelectedRacks();
              hideRackToolbar();
              loadRackTree();
            }
          },
          false,
        );

        const rackConfigPanel = document.querySelector('.fixed.bottom-5.left-5');
        if (rackConfigPanel) {
          rackConfigPanel.addEventListener('click', function (e) {
            e.stopPropagation();
          });
        }

        document.querySelector('.modal-close').addEventListener('click', (e) => {
          e.stopPropagation();
          modal.style.display = 'none';
        });
        document.getElementById('close-modal').addEventListener('click', (e) => {
          e.stopPropagation();
          modal.style.display = 'none';
        });

        renderer.domElement.addEventListener('mousedown', (event) => {
          dragStartX = event.clientX;
          dragStartY = event.clientY;
          isDragging = false;

          if (editMode && selectedRacks.length > 0) {
            // 랙 드래그 로직 (파렛트 선택 해제로 경쟁 조건 방지)
            clearSelectedPallets();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            let found = false;
            selectedRacks.forEach((rackObj) => {
              const intersects = raycaster.intersectObject(rackObj, true);
              if (intersects.length > 0) {
                found = true;
              }
            });
            if (found) {
              isRackDragging = true;
              rackDragOffsets = new Map();
              selectedRacks.forEach((rackObj) => {
                let plane = new THREE.Plane();
                plane.setFromNormalAndCoplanarPoint(
                  new THREE.Vector3(0, 1, 0),
                  new THREE.Vector3(0, rackObj.position.y, 0),
                );
                let intersectionPoint = new THREE.Vector3();
                raycaster.ray.intersectPlane(plane, intersectionPoint);
                let offset = new THREE.Vector3().subVectors(intersectionPoint, rackObj.position);
                rackDragOffsets.set(rackObj, offset);
              });
              controls.enabled = false;
            }
          } else if (editMode && selectedPallets.length > 0) {
            // 파렛트 드래그 로직 (랙 선택 해제로 경쟁 조건 방지)
            clearSelectedRacks();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            let found = false;
            selectedPallets.forEach((palletObj) => {
              const intersects = raycaster.intersectObject(palletObj, true);
              if (intersects.length > 0) {
                found = true;
              }
            });
            if (found) {
              isPalletDragging = true;
              palletDragOffsets = new Map();
              selectedPallets.forEach((palletObj) => {
                let plane = new THREE.Plane();
                plane.setFromNormalAndCoplanarPoint(
                  new THREE.Vector3(0, 1, 0),
                  new THREE.Vector3(0, palletObj.position.y, 0),
                );
                let intersectionPoint = new THREE.Vector3();
                raycaster.ray.intersectPlane(plane, intersectionPoint);
                let offset = new THREE.Vector3().subVectors(intersectionPoint, palletObj.position);
                palletDragOffsets.set(palletObj, offset);
              });
              controls.enabled = false;
            }
          }
        });

        renderer.domElement.addEventListener('mouseup', (event) => {
          const wasDraggingRack = isRackDragging;
          isRackDragging = false;
          isPalletDragging = false; // 파렛트 드래그 해제 추가
          controls.enabled = true;
          if (editMode && wasDraggingRack) {
            saveAllRackConfigs();
          }
        });

        // 툴바 변수 초기화
        rackToolbar = document.getElementById('rack-toolbar');
        toolbarCloseBtn = document.getElementById('toolbar-close');
        toolbarApplyBtn = document.getElementById('toolbar-apply');
        toolbarDeleteBtn = document.getElementById('toolbar-delete');
        toolbarInputs = {
          rackId: document.getElementById('toolbar-rack-id'),
          width: document.getElementById('toolbar-rack-width'),
          depth: document.getElementById('toolbar-rack-depth'),
          height: document.getElementById('toolbar-rack-height'),
          levels: document.getElementById('toolbar-rack-levels'),
          cells: document.getElementById('toolbar-rack-cells'),
          rotation: document.getElementById('toolbar-rack-rotation'),
          group: document.getElementById('cfg-group-select'),
        };

        // 복사된 랙 ID용 유틸
        function getNextCopyId() {
          const prefix = '복사된 랙 #';
          let maxIndex = 0;
          racks.forEach((r) => {
            const id = r.userData.rackId;
            if (id.startsWith(prefix)) {
              const num = parseInt(id.slice(prefix.length), 10);
              if (!isNaN(num) && num > maxIndex) maxIndex = num;
            }
          });
          return `${prefix}${maxIndex + 1}`;
        }

        window.addEventListener('keydown', async (e) => {
          // Mac 은 metaKey, Windows/Linux 는 ctrlKey
          const isCopy = (e.ctrlKey || e.metaKey) && (e.key === 'c' || e.key === 'C');
          const isPaste = (e.ctrlKey || e.metaKey) && (e.key === 'v' || e.key === 'V');

          if (isCopy) {
            // 선택된 랙(selectedRacks)을 복사 버퍼에 저장
            copyBuffer = selectedRacks.map((rack) => ({
              config: { ...rack.userData.config },
              templateId: rack.userData.templateId,
              position: rack.position.clone(),
              rotation: rack.userData.config.rotation || 0,
            }));
            console.log('복사된 랙 수:', copyBuffer.length);
            e.preventDefault();
          }

          if (isPaste && copyBuffer.length > 0) {
            for (const { config, templateId, position, rotation } of copyBuffer) {
              // 1) 중복 없는 새로운 ID 생성
              const newId = getNextCopyId();

              // 2) createRack 으로 새 랙 생성
              const newRack = createRack(
                newId,
                config.width,
                config.depth,
                config.height,
                config.levels,
                config.cells,
                null,
                true,
                templateId,
              );

              // 3) 위치·회전 복사
              newRack.position.copy(position).add(new THREE.Vector3(1, 0, 1));
              newRack.rotation.y = THREE.MathUtils.degToRad(rotation);
              newRack.userData.config.rotation = rotation;

              // 4) 데이터 매핑
              await loadDataAndMapForRack(newRack);

              // 5) racks 배열에도 추가
              racks.push(newRack);
            }

            // 6) 저장 및 UI 갱신
            saveAllRackConfigs();
            e.preventDefault();
          }
        });

        populateConfigPanelGroupDropdown();
        document.getElementById('apply-all-config').addEventListener('click', applyAllRackConfig);

        document.querySelectorAll('input[name="shadowQuality"]').forEach((radio) => {
          radio.addEventListener('change', updateShadowQuality);
        });

        // 그리고 초기값(checked 상태)을 반영하려면 한 번 실행
        updateShadowQuality();

        // FPS 토글 초기화 (stats가 초기화된 후 실행)
        initializeFPSToggle();

        animate();
        setEditMode(false); // 최초 실행은 뷰어 모드
        updateCellVisibility();
      }

      // 공통 처리 함수
      function applyCfgPanelConfig() {
        if (selectedRacks.length !== 1) return;
        const rackObj = selectedRacks[0];
        const newConfig = {
          rackId: rackObj.userData.rackId,
          width:
            parseFloat(document.getElementById('cfg-width').value) || rackObj.userData.config.width,
          depth:
            parseFloat(document.getElementById('cfg-depth').value) || rackObj.userData.config.depth,
          height:
            parseFloat(document.getElementById('cfg-height').value) ||
            rackObj.userData.config.height,
          levels:
            parseInt(document.getElementById('cfg-levels').value, 10) ||
            rackObj.userData.config.levels,
          cells:
            parseInt(document.getElementById('cfg-cells').value, 10) ||
            rackObj.userData.config.cells,
          rotation:
            parseFloat(document.getElementById('cfg-rotation-value').value) ||
            rackObj.userData.config.rotation,
          group: document.getElementById('cfg-group-select').value,
        };

        updateRackConfig(rackObj, newConfig);
        saveAllRackConfigs();
        updateToolbarPosition(rackObj);
      }

      function populateConfigPanelGroupDropdown() {
        const sel = document.getElementById('cfg-group-select');
        sel.innerHTML = '';
        rackGroups.forEach((g) => {
          const opt = document.createElement('option');
          opt.value = g;
          opt.textContent = g;
          sel.appendChild(opt);
        });
      }

      function populateFloorTemplateSelect() {
        const sel = document.getElementById('cfg-floor-template-select');
        sel.innerHTML = '';
        Object.entries(floorTemplates).forEach(([id, tpl]) => {
          const opt = document.createElement('option');
          opt.value = id;
          opt.textContent = tpl.name || id;
          sel.appendChild(opt);
        });
      }

      function onFloorTemplateChange() {
        const id = this.value;
        const tpl = floorTemplates[id];
        if (!tpl) return;
        // 인풋에 값을 채워주고
        document.getElementById('cfg-floor-width').value = tpl.width;
        document.getElementById('cfg-floor-depth').value = tpl.depth;
        document.getElementById('cfg-floor-thickness').value = tpl.thickness;
        document.getElementById('cfg-floor-color').value =
          '#' + tpl.color.toString(16).padStart(6, '0');
        document.getElementById('cfg-floor-opacity').value = tpl.opacity;
        document.getElementById('cfg-floor-shadow').checked = tpl.receiveShadow;
        // 씬에도 즉시 반영
        applyFloorSettings();
      }

      // 4) 인풋 변경 시, 해당 템플릿 객체에 반영하고 저장
      function onFloorInputChange() {
        const sel = document.getElementById('cfg-floor-template-select');
        const id = sel.value;
        const tpl = floorTemplates[id];
        if (!tpl) return;
        tpl.width = parseFloat(document.getElementById('cfg-floor-width').value) || tpl.width;
        tpl.depth = parseFloat(document.getElementById('cfg-floor-depth').value) || tpl.depth;
        tpl.thickness =
          parseFloat(document.getElementById('cfg-floor-thickness').value) || tpl.thickness;
        tpl.color = parseInt(document.getElementById('cfg-floor-color').value.replace('#', ''), 16);
        tpl.opacity = parseFloat(document.getElementById('cfg-floor-opacity').value) || tpl.opacity;
        tpl.receiveShadow = document.getElementById('cfg-floor-shadow').checked;
        // 로컬스토리지 갱신
        localStorage.setItem('floorTemplates', JSON.stringify(floorTemplates));
        // 씬 업데이트
        applyFloorSettings();
      }

      // 5) 페이지 로드시 초기화
      window.addEventListener('DOMContentLoaded', () => {
        loadFloorTemplatesFromStorage();
        populateFloorTemplateSelect();
        // 이벤트 연결
        document
          .getElementById('cfg-floor-template-select')
          .addEventListener('change', onFloorTemplateChange);
        [
          'cfg-floor-width',
          'cfg-floor-depth',
          'cfg-floor-thickness',
          'cfg-floor-color',
          'cfg-floor-opacity',
          'cfg-floor-shadow',
        ].forEach((id) => {
          document.getElementById(id).addEventListener('input', onFloorInputChange);
        });
        // 기본 선택된 템플릿이 있으면 로딩
        const sel = document.getElementById('cfg-floor-template-select');
        if (sel.options.length) {
          sel.selectedIndex = 0;
          sel.dispatchEvent(new Event('change'));
        }
      });

      // 기본 설정 로드
      function loadDefaultSettings() {
        const storedSettings = localStorage.getItem('defaultSettings');
        if (storedSettings) {
          defaultSettings = JSON.parse(storedSettings);
        } else {
          // 기본값 설정 (최초 실행 시)
          defaultSettings = {
            defaultFloorTemplateId: null,
            defaultRackTemplateId: 'default',
          };
          localStorage.setItem('defaultSettings', JSON.stringify(defaultSettings));
        }
      }

      // 기본 설정 저장
      function saveDefaultSettings() {
        localStorage.setItem('defaultSettings', JSON.stringify(defaultSettings));
      }

      // 툴바 표시 함수
      function showRackToolbar(rackObj) {
        if (!rackObj || !rackObj.userData || !rackObj.userData.config) return;

        // 툴바 표시
        rackToolbar.classList.remove('hidden');

        // 툴바 입력 필드에 현재 랙 설정 값 설정
        const config = rackObj.userData.config;
        toolbarInputs.rackId.value = rackObj.userData.rackId || ''; // 랙 ID 설정
        toolbarInputs.width.value = config.width || 5;
        toolbarInputs.depth.value = config.depth || 1.5;
        toolbarInputs.height.value = config.height || 5;
        toolbarInputs.levels.value = config.levels || 5;
        toolbarInputs.cells.value = config.cells || 4;
        toolbarInputs.rotation.value = THREE.MathUtils.radToDeg(rackObj.rotation.y) || 0;
        if (toolbarInputs.group) toolbarInputs.group.value = config.group || '기본';
        // 툴바 위치 조정
        updateToolbarPosition(rackObj);
      }

      // 툴바 위치 업데이트 함수
      function updateToolbarPosition(rackObj) {
        if (!rackObj) return;

        // 랙의 바운딩 박스 계산
        const bbox = new THREE.Box3().setFromObject(rackObj);
        const center = bbox.getCenter(new THREE.Vector3());
        const size = bbox.getSize(new THREE.Vector3());

        // 랙 상단 중앙 위치 (y축 기준으로 상단)
        const rackTopCenter = new THREE.Vector3(center.x, bbox.max.y + 0.5, center.z);

        // 3D 좌표를 화면 좌표로 변환
        rackTopCenter.project(camera);

        const halfWidth = window.innerWidth / 2;
        const halfHeight = window.innerHeight / 2;
        const toolbarWidth = rackToolbar.offsetWidth;
        const toolbarHeight = rackToolbar.offsetHeight;

        // 화면 좌표로 변환 (툴바를 랙 상단 중앙에 위치시키되, 약간 위로 오프셋)
        const x = rackTopCenter.x * halfWidth + halfWidth - toolbarWidth / 2;
        const y = -(rackTopCenter.y * halfHeight) + halfHeight - toolbarHeight - 10; // 10px 위로 오프셋

        rackToolbar.style.left = `${x}px`;
        rackToolbar.style.top = `${y}px`;
      }

      // 툴바 숨기기 함수
      function hideRackToolbar() {
        rackToolbar.classList.add('hidden');
      }

      // 랙 구성 업데이트 함수
      function updateRackConfig(rackObj, newConfig) {
        const oldRackId = rackObj.userData.rackId;
        const selectedGroup = document.getElementById('cfg-group-select').value;

        // (1) ID‐change collision check
        if (newConfig.rackId && newConfig.rackId !== oldRackId) {
          if (racks.some((r) => r.userData.rackId === newConfig.rackId)) {
            alert(`랙 ID "${newConfig.rackId}"는 이미 사용 중입니다.`);
            return;
          }
        }

        // (2) remember position & cell-addresses
        const oldPos = rackObj.position.clone();
        const preservedCellAddresses = rackObj.userData.cells.map((row, i) =>
          row.map((_, j) => `${oldRackId}-${String.fromCharCode(65 + i)}${j + 1}`),
        );

        // (3) tear out the old rack
        removeRackCompletely(rackObj);
        racks = racks.filter((r) => r.userData.rackId !== oldRackId);

        // (4) create the new one with your dimensions/template
        const tpl = rackObj.userData.templateId;
        const newRack = createRack(
          newConfig.rackId || oldRackId,
          newConfig.width,
          newConfig.depth,
          newConfig.height,
          newConfig.levels,
          newConfig.cells,
          rackObj.userData.cells, // preserve the actual data array
          false,
          tpl,
        );

        // (5) restore transform
        newRack.position.copy(oldPos);
        newRack.rotation.y = THREE.MathUtils.degToRad(newConfig.rotation);
        newRack.updateMatrixWorld();

        // (6) overwrite the config *and* make sure to set its group
        newRack.userData.config = {
          rackId: newConfig.rackId || oldRackId,
          width: newConfig.width,
          depth: newConfig.depth,
          height: newConfig.height,
          levels: newConfig.levels,
          cells: newConfig.cells,
          rotation: newConfig.rotation,
          group: selectedGroup, // ← **here is the fix**
        };

        // (7) snap it back onto the floor
        const floorY = getFloorTopY();
        const bb = new THREE.Box3().setFromObject(newRack);
        newRack.position.y += floorY - bb.min.y;

        // (8) remap your cell-data
        loadDataAndMapForRack(newRack, preservedCellAddresses);

        // (9) re-add it
        racks.push(newRack);

        // (10) keep it selected
        clearSelectedRacks();
        clearMeasurementVisuals();
        selectedRacks = [newRack];
        if (editMode) {
          const helper = new THREE.BoxHelper(
            newRack.getObjectByName('rackStructureGroup') || newRack,
            0xc4ff2e,
          );
          scene.add(helper);
          selectedRackHelpers = [{ rack: newRack, helper }];
        }

        updateToolbarPosition(newRack);

        // (11) clean up localStorage if the ID itself changed
        if (newConfig.rackId && newConfig.rackId !== oldRackId) {
          localStorage.removeItem(`rackConfig_${oldRackId}`);
        }

        // (12) finally persist everything
        saveAllRackConfigs();
      }

      function loadRackTree() {
        const tree = document.getElementById('rack-tree');
        const prevScroll = tree.scrollTop;

        // 이전 열린 그룹 상태 저장
        saveOpenGroups();

        // 초기화
        tree.innerHTML = '';

        // 저장된 모든 랙 설정 (데이터 검증 포함)
        const configs = (JSON.parse(localStorage.getItem('allRackConfigs')) || []).filter(
          validateRackConfig,
        );

        rackGroups.forEach((groupName) => {
          // 이 그룹에 속한 랙만 필터
          const groupConfigs = configs.filter((cfg) => (cfg.group || '기본') === groupName);

          // <details> 생성
          const details = document.createElement('details');
          details.dataset.group = groupName;
          details.className = 'mb-2';
          if (openGroups.includes(groupName)) details.open = true;

          // <summary> 생성
          const summary = document.createElement('summary');
          summary.className = `
      flex items-center justify-between
      bg-gray-700 hover:bg-gray-600
      text-gray-200 hover:text-white
      px-2 py-1 rounded-md
      cursor-pointer transition-all duration-200
    `.trim();

          // 화살표 아이콘
          const arrow = document.createElement('i');
          arrow.className = 'fas fa-chevron-right text-xs transition-transform duration-200';
          summary.appendChild(arrow);

          // 그룹명 + 개수
          const nameSpan = document.createElement('span');
          nameSpan.className = 'ml-2 text-xs';
          nameSpan.textContent = `${groupName} (${groupConfigs.length})`;
          summary.appendChild(nameSpan);

          // ⋮ 메뉴 버튼
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.className =
            'ml-auto w-6 text-gray-400 hover:text-white p-1 rounded-md hover:bg-gray-700 transition-colors duration-200';
          btn.innerHTML = '<i class="fas fa-ellipsis-v"></i>';
          summary.appendChild(btn);

          details.appendChild(summary);

          // summary 클릭 시 화살표 회전
          summary.addEventListener('click', () => {
            arrow.classList.toggle('rotate-90');
          });

          // drag & drop 처리
          details.addEventListener('dragover', (e) => {
            e.preventDefault();
            details.classList.add('bg-gray-600');
          });
          details.addEventListener('dragleave', () => {
            details.classList.remove('bg-gray-600');
          });
          details.addEventListener('drop', (e) => {
            e.preventDefault();
            details.classList.remove('bg-gray-600');
            const rackId = e.dataTransfer.getData('text/plain');
            const all = (JSON.parse(localStorage.getItem('allRackConfigs')) || []).filter(
              validateRackConfig,
            );
            const target = all.find((c) => c.rackId === rackId);
            if (target) {
              target.group = groupName;
              safeLocalStorageSet('allRackConfigs', JSON.stringify(all));
              const rackObj = racks.find((r) => r.userData.rackId === rackId);
              if (rackObj) rackObj.userData.config.group = groupName;
              loadRackTree();
            }
          });

          // ⋮ 메뉴 팝업
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            closeAllFolderMenus();
            const menu = document.createElement('div');
            menu.className = `
        folder-menu absolute bg-gray-800 text-white
        rounded-lg shadow-lg z-50
      `.trim();
            menu.innerHTML = `
        <button class="block w-full text-left text-xs px-4 py-2 hover:bg-gray-700 rename-btn">
          폴더명 수정
        </button>
         <button class="block w-full text-left text-xs px-4 py-2 hover:bg-gray-700 rename-btn">
          랙 전체 선택
        </button>
                 <button class="block w-full text-left text-xs px-4 py-2 hover:bg-gray-700 rename-btn">
          랙 전체 숨기
        </button>
      `;
            document.body.appendChild(menu);
            const rect = btn.getBoundingClientRect();
            menu.style.top = `${rect.bottom + window.scrollY}px`;
            menu.style.left = `${rect.left + window.scrollX}px`;

            menu.querySelector('.rename-btn').addEventListener('click', () => {
              menu.remove();
              const input = document.createElement('input');
              input.type = 'text';
              input.value = groupName;
              input.className =
                'w-32 px-2 py-1 text-xs bg-gray-700 text-white rounded focus:outline-none';
              summary.replaceChild(input, nameSpan);
              input.focus();
              function commit() {
                const newName = input.value.trim() || groupName;
                const idx = rackGroups.indexOf(groupName);
                rackGroups[idx] = newName;
                saveGroups();
                const allCfgs = JSON.parse(localStorage.getItem('allRackConfigs')) || [];
                allCfgs.forEach((cfg) => {
                  if ((cfg.group || '기본') === groupName) cfg.group = newName;
                });
                localStorage.setItem('allRackConfigs', JSON.stringify(allCfgs));
                loadRackTree();
              }
              input.addEventListener('keydown', (ev) => {
                if (ev.key === 'Enter') input.blur();
              });
              input.addEventListener('blur', commit);
            });
          });

          // 랙 리스트
          const ul = document.createElement('ul');
          ul.className = 'mt-2 pl-6 space-y-1';

          groupConfigs.forEach((cfg) => {
            const li = document.createElement('li');
            li.draggable = true;
            li.className = `
        flex items-center justify-between
        px-2 py-1 rounded hover:bg-gray-700
        cursor-pointer transition-colors duration-150
      `.trim();

            li.addEventListener('dragstart', (e) => {
              e.dataTransfer.setData('text/plain', cfg.rackId);
            });

            // 레이블
            const label = document.createElement('span');
            label.className = 'text-gray-200 text-xs';
            label.textContent = cfg.rackId;
            label.addEventListener('click', (e) => {
              e.stopPropagation();
              const rackObj = racks.find((r) => r.userData.rackId === cfg.rackId);
              if (!rackObj || !rackObj.visible) return;
              clearSelectedRacks();
              clearSelectedPallets();
              clearMeasurementVisuals();
              hideRackToolbar();
              const helper = new THREE.BoxHelper(
                rackObj.getObjectByName('rackStructureGroup') || rackObj,
                0xc4ff2e,
              );
              scene.add(helper);
              selectedRackHelpers.push({ rack: rackObj, helper });
              selectedRacks = [rackObj];
              focusOnMeshes([rackObj]);
            });
            li.appendChild(label);

            // 눈 아이콘
            const eyeBtn = document.createElement('button');
            eyeBtn.type = 'button';
            eyeBtn.className = 'text-gray-400 hover:text-white';
            eyeBtn.dataset.rackId = cfg.rackId;
            const visible = cfg.visible !== false;
            eyeBtn.innerHTML = `<i class="${
              visible ? 'fas fa-eye text-xs' : 'fas fa-eye-slash text-xs'
            }"></i>`;
            if (!visible) eyeBtn.classList.add('opacity-50');
            eyeBtn.addEventListener('click', (e) => {
              e.stopPropagation();
              const id = e.currentTarget.dataset.rackId;
              const rackObj = racks.find((r) => r.userData.rackId === id);
              if (!rackObj) return;
              rackObj.visible = !rackObj.visible;
              e.currentTarget.classList.toggle('opacity-50', !rackObj.visible);
              const icon = e.currentTarget.querySelector('i');
              icon.classList.toggle('fa-eye', rackObj.visible);
              icon.classList.toggle('fa-eye-slash', !rackObj.visible);
              const all = JSON.parse(localStorage.getItem('allRackConfigs')) || [];
              const tgt = all.find((c) => c.rackId === id);
              if (tgt) {
                tgt.visible = rackObj.visible;
                localStorage.setItem('allRackConfigs', JSON.stringify(all));
              }
              if (!rackObj.visible) {
                // helper 제거
                selectedRackHelpers = selectedRackHelpers.filter(({ rack, helper }) => {
                  if (rack === rackObj) {
                    scene.remove(helper);
                    return false;
                  }
                  return true;
                });
                selectedRacks = selectedRacks.filter((r) => r !== rackObj);
                hideRackToolbar();
              }
            });
            li.appendChild(eyeBtn);

            ul.appendChild(li);
          });

          details.appendChild(ul);
          tree.appendChild(details);
        }); // rackGroups.forEach

        tree.scrollTop = prevScroll;
      }

      function closeAllFolderMenus() {
        document.querySelectorAll('.folder-menu').forEach((menu) => menu.remove());
      }

      // 문서 어디든 클릭하면 메뉴 닫기
      window.addEventListener('click', (e) => {
        if (!e.target.closest('.menu-btn') && !e.target.closest('.folder-menu')) {
          closeAllFolderMenus();
        }
      });

      // 2) 오른쪽 패널에 랙 구성 세팅 표시
      function showRackConfig(cfg) {
        // 폼 필드에 값 채우기
        document.getElementById('cfg-rack-id').value = cfg.rackId;
        document.getElementById('cfg-width').value = cfg.width;
        document.getElementById('cfg-depth').value = cfg.depth;
        document.getElementById('cfg-height').value = cfg.height;
        document.getElementById('cfg-levels').value = cfg.levels;
        document.getElementById('cfg-cells').value = cfg.cells;
        document.getElementById('cfg-rotation-value').value = cfg.rotation;
        document.getElementById('cfg-group-select').value = cfg.group || '기본';
        // 오른쪽 패널 보이기
        document.getElementById('rack-config-panel').classList.remove('hidden');
      }

      // ------------ in init(), after you append the panel to <body> ------------

      // 예시) rackId로 씬 내 랙 찾아 포커스
      function focusOnRackById(rackId) {
        const rack = racks.find((r) => r.userData.rackId === rackId);
        if (!rack) return;
        // 기존 검색 focusOnMeshes와 유사하게 카메라 이동
        focusOnMeshes([rack]);
      }

      // 초기 로드
      window.addEventListener('DOMContentLoaded', loadRackTree);

      const origSave = saveAllRackConfigs;
      saveAllRackConfigs = function () {
        origSave();
        loadRackTree();
      };

      // 툴바 입력 값 변경 시 호출되는 함수
      function updateRackFromToolbar() {
        if (selectedRacks.length !== 1) return;

        const rackObj = selectedRacks[0];
        const newConfig = {
          rackId: toolbarInputs.rackId.value.trim() || rackObj.userData.rackId,
          width: Math.max(1, parseFloat(toolbarInputs.width.value) || 5),
          depth: Math.max(1, parseFloat(toolbarInputs.depth.value) || 1.5),
          height: Math.max(1, parseFloat(toolbarInputs.height.value) || 5),
          levels: Math.max(1, parseInt(toolbarInputs.levels.value) || 5),
          cells: Math.max(1, parseInt(toolbarInputs.cells.value) || 4),
          rotation: parseFloat(toolbarInputs.rotation.value) || 0,
        };

        updateRackConfig(rackObj, newConfig);
        saveAllRackConfigs();
      }

      function deleteSelectedRack() {
        if (selectedRack) {
          const idToDelete = selectedRack.userData.internalId;
          scene.remove(selectedRack);
          const index = racks.findIndex((rack) => rack.userData.internalId === idToDelete);
          if (index !== -1) {
            racks.splice(index, 1);
          }
          if (selectedRackHelper) {
            scene.remove(selectedRackHelper);
            selectedRackHelper = null;
          }
          selectedRack = null;
          document.getElementById('rack-id').value = '';
          saveAllRackConfigs();
        }
      }

      // ----------------------------------------------------
      // 오브젝트의 월드 반치수(half‑extents)를 계산하는 헬퍼
      // rack.userData.config.width, depth 와 rack.rotation.y 사용
      // ----------------------------------------------------
      function getWorldHalfExtents(rack) {
        const w = rack.userData.config.width;
        const d = rack.userData.config.depth;
        const θ = rack.rotation.y; // Y축 회전 (라디안)
        const hx = w / 2,
          hz = d / 2;
        // X축·Z축으로 투영된 반치수
        const halfX = Math.abs(Math.cos(θ) * hx) + Math.abs(Math.sin(θ) * hz);
        const halfZ = Math.abs(Math.sin(θ) * hx) + Math.abs(Math.cos(θ) * hz);
        return { halfX, halfZ };
      }

      // =======================================
      // 1) updateAlignmentHelpers
      //    – X/Z 면이 딱 붙는 순간에만 수직/수평 가이드
      // =======================================
      function updateAlignmentHelpers() {
        alignmentHelpers.forEach((h) => scene.remove(h));
        alignmentHelpers = [];

        if (selectedRacks.length !== 1) return;
        const rack = selectedRacks[0];
        const { halfX: selHX, halfZ: selHZ } = getWorldHalfExtents(rack);
        const selX = rack.position.x,
          selZ = rack.position.z;
        const selL = selX - selHX,
          selR = selX + selHX;
        const selB = selZ - selHZ,
          selF = selZ + selHZ;

        let y = 0.01;
        if (floorMesh?.geometry?.parameters) {
          y = floorMesh.position.y + floorMesh.geometry.parameters.height / 2 + 0.01;
        }

        const mat = new THREE.MeshBasicMaterial({
          color: 0x00ff00,
          transparent: true,
          opacity: 0.8,
          depthTest: true,
          depthWrite: true,
          side: THREE.DoubleSide,
        });
        const opts = { tubularSegments: 20, tubeRadius: 0.02, radialSegments: 8 };
        const thr = 0.5;

        racks.forEach((other) => {
          if (other === rack) return;
          const { halfX: oHX, halfZ: oHZ } = getWorldHalfExtents(other);
          const oX = other.position.x,
            oZ = other.position.z;
          const oL = oX - oHX,
            oR = oX + oHX;
          const oB = oZ - oHZ,
            oF = oZ + oHZ;

          // ── X축 수직선 ──
          if (Math.abs(selL - oR) < thr) {
            const path = new THREE.CatmullRomCurve3([
              new THREE.Vector3(oR, y, Math.min(selB, oB) - 1),
              new THREE.Vector3(oR, y, Math.max(selF, oF) + 1),
            ]);
            alignmentHelpers.push(
              new THREE.Mesh(new THREE.TubeGeometry(path, ...Object.values(opts)), mat),
            );
          } else if (Math.abs(selR - oL) < thr) {
            const path = new THREE.CatmullRomCurve3([
              new THREE.Vector3(oL, y, Math.min(selB, oB) - 1),
              new THREE.Vector3(oL, y, Math.max(selF, oF) + 1),
            ]);
            alignmentHelpers.push(
              new THREE.Mesh(new THREE.TubeGeometry(path, ...Object.values(opts)), mat),
            );
          }

          // ── Z축 수평선 ──
          if (Math.abs(selF - oB) < thr || Math.abs(selF - oF) < thr) {
            // 앞-뒤 or 앞-앞
            const z = Math.abs(selF - oB) < Math.abs(selF - oF) ? oB : oF;
            const path = new THREE.CatmullRomCurve3([
              new THREE.Vector3(Math.min(selL, oL) - 1, y, z),
              new THREE.Vector3(Math.max(selR, oR) + 1, y, z),
            ]);
            alignmentHelpers.push(
              new THREE.Mesh(new THREE.TubeGeometry(path, ...Object.values(opts)), mat),
            );
          } else if (Math.abs(selB - oF) < thr || Math.abs(selB - oB) < thr) {
            // 뒤-앞 or 뒤-뒤
            const z = Math.abs(selB - oF) < Math.abs(selB - oB) ? oF : oB;
            const path = new THREE.CatmullRomCurve3([
              new THREE.Vector3(Math.min(selL, oL) - 1, y, z),
              new THREE.Vector3(Math.max(selR, oR) + 1, y, z),
            ]);
            alignmentHelpers.push(
              new THREE.Mesh(new THREE.TubeGeometry(path, ...Object.values(opts)), mat),
            );
          }
        });

        // 씬에 추가
        alignmentHelpers.forEach((h) => scene.add(h));
      }

      // function removeOldRackElements(rack) {
      //   if (!rack || typeof rack.traverse !== 'function') {
      //     console.warn('Invalid rack object in removeOldRackElements:', rack);
      //     return;
      //   }

      //   console.log(`Removing elements for rack: ${rack.userData.rackId} with UUID: ${rack.uuid}`);

      //   const childrenToRemove = [];
      //   rack.traverse((child) => {
      //     if (
      //       child.userData &&
      //       (child.userData.isCell ||
      //         child.name === 'rackCellGroup' ||
      //         child.name === 'rackStructureGroup')
      //     ) {
      //       childrenToRemove.push(child);
      //       if (child.geometry) child.geometry.dispose();
      //       if (child.material) {
      //         if (Array.isArray(child.material)) child.material.forEach((m) => m.dispose());
      //         else child.material.dispose();
      //       }
      //     }
      //   });

      //   childrenToRemove.forEach((child) => {
      //     if (child.parent) child.parent.remove(child);
      //   });

      //   // Clean up global arrays
      //   cellMeshes = cellMeshes.filter((mesh) => mesh.userData.rackId !== rack.userData.rackId);
      //   labelSprites = labelSprites.filter(
      //     (sprite) => !(sprite.userData && sprite.userData.rackId === rack.userData.rackId),
      //   );

      //   // Ensure the rack itself is removed from its parent if necessary
      //   if (rack.parent) {
      //     rack.parent.remove(rack);
      //   }

      //   tooltip.style.display = 'none';
      // }

      // 드롭다운에 옵션 채우기
      function populateGroupSelect() {
        const sel = document.getElementById('cfg-group');
        sel.innerHTML = '';
        rackGroups.forEach((g) => {
          const opt = document.createElement('option');
          opt.value = g;
          opt.textContent = g;
          sel.appendChild(opt);
        });
      }

      document.getElementById('add-group-btn').addEventListener('click', () => {
        const name = prompt('새 그룹 이름을 입력하세요:');
        if (!name) return;
        if (rackGroups.includes(name)) {
          alert('이미 존재하는 그룹입니다.');
          return;
        }
        rackGroups.push(name);
        saveGroups();
        populateGroupSelect();
      });

      // 앱 로드 직후
      populateGroupSelect();

      function saveRackConfig(rack) {
        const config = Object.assign({}, rack.userData.config, {
          rackId: rack.userData.rackId,
          posX: rack.position.x,
          posY: rack.position.y,
          posZ: rack.position.z,
          rotation: THREE.MathUtils.radToDeg(rack.rotation.y),
        });
        localStorage.setItem('rackConfig_' + config.rackId, JSON.stringify(config));
        console.log('Saved rack config:', config);
      }

      function saveAllRackConfigs() {
        // 중복 랙 제거 (rackId 기준)
        const uniqueRacks = [];
        const seenRackIds = new Set();

        for (const rack of racks) {
          if (!seenRackIds.has(rack.userData.rackId)) {
            seenRackIds.add(rack.userData.rackId);
            uniqueRacks.push(rack);
          }
        }

        // racks 배열 업데이트
        racks.length = 0;
        racks.push(...uniqueRacks);

        // 중복 파렛트 제거 (palletId 기준)
        const uniquePallets = [];
        const seenPalletIds = new Set();

        for (const pallet of pallets) {
          if (!seenPalletIds.has(pallet.userData.palletId)) {
            seenPalletIds.add(pallet.userData.palletId);
            uniquePallets.push(pallet);
          }
        }

        // pallets 배열 업데이트
        pallets.length = 0;
        pallets.push(...uniquePallets);

        // preview 및 temp 랙 제외하고 저장
        const rackConfigs = racks
          .filter((rack) => rack.userData.rackId !== 'preview' && rack.userData.rackId !== 'temp')
          .map((rack) => ({
            rackId: rack.userData.rackId,
            width: rack.userData.config.width,
            depth: rack.userData.config.depth,
            height: rack.userData.config.height,
            levels: rack.userData.config.levels,
            cells: rack.userData.config.cells,
            rotation: rack.userData.config.rotation || 0,
            posX: rack.position.x,
            posY: rack.position.y,
            posZ: rack.position.z,
            templateId: rack.userData.templateId || 'default',
            group: rack.userData.config.group || '기본',
            visible: rack.visible,
          }));

        // 파렛트 설정 저장
        const palletConfigs = pallets
          .filter(
            (pallet) =>
              pallet.userData.palletId !== 'preview' && pallet.userData.palletId !== 'temp',
          ) // preview와 temp 제외
          .map((pallet) => ({
            palletId: pallet.userData.palletId,
            posX: pallet.position.x,
            posY: pallet.position.y,
            posZ: pallet.position.z,
            rotation: THREE.MathUtils.radToDeg(pallet.rotation.y) || 0, // 회전값을 도 단위로 저장
            templateId: pallet.userData.templateId || 'yellowPallet', // 기본 템플릿 ID
          }));

        // 로컬 스토리지에 저장
        localStorage.setItem('allRackConfigs', JSON.stringify(rackConfigs));
        localStorage.setItem('allPalletConfigs', JSON.stringify(palletConfigs));

        loadRackTree(); // 트리뷰 자동 갱신
      }

      async function loadAllRackConfigs() {
        const configArrayStr = localStorage.getItem('allRackConfigs');
        if (!configArrayStr) {
          document.getElementById('loading-screen').style.display = 'none';
          return;
        }

        const configArray = JSON.parse(configArrayStr);
        racks = [];

        for (const config of configArray) {
          if (racks.find((r) => r.userData.rackId === config.rackId)) continue;

          const newRack = createRack(
            config.rackId,
            config.width,
            config.depth,
            config.height,
            config.levels,
            config.cells,
          );

          // restore transform
          newRack.position.set(config.posX || 0, config.posY || 0, config.posZ || 0);
          newRack.rotation.y = THREE.MathUtils.degToRad(config.rotation || 0);

          // **RESTORE GROUP HERE**
          newRack.userData.config.group = config.group || '기본';

          // restore visibility
          newRack.visible = config.visible !== false;

          // restore cell-data
          await loadDataAndMapForRack(newRack, config.cellData);

          scene.add(newRack);
          racks.push(newRack);

          if (editMode) {
            const structure = newRack.getObjectByName('rackStructureGroup') || newRack;
            const helper = new THREE.BoxHelper(structure, 0xc4ff2e);
            helper.update();
            scene.add(helper);
            selectedRackHelpers.push({ rack: newRack, helper });
          }
        }

        document.getElementById('loading-screen').style.display = 'none';
      }

      function createFloor(config = {}) {
        // 기존 바닥 및 격자 제거
        if (floorMesh) {
          scene.remove(floorMesh);
          floorMesh.geometry.dispose();
          floorMesh.material.dispose();
          floorMesh = null;
        }
        if (gridHelper) {
          scene.remove(gridHelper);
          gridHelper = null;
        }

        // 기본값 설정
        const {
          width = 100,
          depth = 100,
          color = 0xb0b0b0,
          thickness = 0.2, // 두께
          materialType = 'custom',
          opacity = 1,
          receiveShadow = true,
          isEditMode = false,
        } = config;

        // 바닥 생성 (BoxGeometry로 두께 추가)
        const geometry = new THREE.BoxGeometry(width, thickness, depth); // width: 가로, thickness: 두께, depth: 세로
        let material;

        if (materialType === 'custom') {
          material = new THREE.MeshStandardMaterial({
            color: color,
            roughness: 0.8,
            metalness: 0.2,
            transparent: true,
            opacity: opacity,
          });
        } else {
          material = new THREE.MeshStandardMaterial({
            map: textures[materialType],
            roughness: 0.9,
            metalness: 0.1,
            transparent: true,
            opacity: opacity,
          });
        }

        const floor = new THREE.Mesh(geometry, material);
        floor.position.y = thickness / 2; // 바닥의 중심을 기준으로 Y 위치 조정 (Y 위치는 항상 0 기준)
        floor.receiveShadow = renderer.shadowMap.enabled;
        floor.castShadow = false; // 바닥은 그림자를 드리우지 않음
        scene.add(floor);

        // 편집 모드일 경우 격자 추가

        floorMesh = floor;

        // 랙 위치 조정 (바닥 상단에 맞춰 위치)
        racks.forEach((rack) => {
          const floorTopY = thickness; // 바닥의 상단 Y 위치
          const bbox = new THREE.Box3().setFromObject(rack);
          const minY = bbox.min.y;
          if (minY < floorTopY) {
            rack.position.y += floorTopY - minY;
          }
        });

        renderer.render(scene, camera);
        return floor;
      }

      function generateRackData(levelCount, cellsPerLevel) {
        let cells = [];
        for (let level = 0; level < levelCount; level++) {
          let levelCells = [];
          for (let cell = 0; cell < cellsPerLevel; cell++) {
            const hasMaterial = Math.random() > 0.5;
            const cellData = { id: `L${level + 1}-C${cell + 1}`, hasMaterial: hasMaterial };
            if (hasMaterial) {
              cellData.materialId = `MTL-${1000 + level * 10 + cell}`;
              cellData.name = '자재 샘플';
              cellData.quantity = Math.floor(Math.random() * 20) + 1;
              cellData.date = '2023-12-01';
              cellData.status = Math.random() > 0.7 ? '점검 필요' : '양호';
            }
            levelCells.push(cellData);
          }
          cells.push(levelCells);
        }
        return cells;
      }

      function toggleEditMode() {
        editMode = !editMode;
        toggleEditModeBtn.textContent = `편집 모드 (${editMode ? 'ON' : 'OFF'})`; // 1) 렌더러에서 그림자 on/off

        renderer.shadowMap.enabled = !editMode; // 2) 라이트의 castShadow도 같이 on/off

        mainLight.castShadow = !editMode;
        if (spotLight) spotLight.castShadow = !editMode; // 4) 그리드·축 헬퍼 토글

        if (editMode) {
          // [수정 시작]
          // 1. 바닥 크기와 상관없이 그리드 크기를 큰 값으로 고정
          const gridSize = 1000; // 2. 그리드 칸 수도 고정 (1미터당 1칸)
          const divisions = 1000; // 3. 고정된 크기로 GridHelper 생성

          gridHelper = new THREE.GridHelper(gridSize, divisions, 0x8a8a8a, 0xababab); // 4. 그리드를 씬의 원점에 위치시킴 (Y축은 Z-fighting 방지를 위해 살짝 위로)

          gridHelper.position.y = 0.01;
          scene.add(gridHelper); // 5. 축 헬퍼도 적당한 고정 크기(100)로 생성하여 원점에 표시

          axesHelper = new THREE.AxesHelper(100);
          axesHelper.position.y = 0.02; // 그리드보다 살짝 위
          scene.add(axesHelper); // [수정 끝]
        } else {
          clearSelectedRacks();
          hideRackToolbar();
          clearMeasurementVisuals();

          if (gridHelper) scene.remove(gridHelper);
          if (axesHelper) scene.remove(axesHelper);
        }
      }

      function setupLights() {
        const ambientLight = new THREE.AmbientLight(0xffffff, 2.0);
        scene.add(ambientLight);

        mainLight = new THREE.DirectionalLight(0xffffff, 2.4);
        mainLight.position.set(5, 10, 7);
        mainLight.castShadow = true;

        mainLight.shadow.mapSize.set(2048, 2048); // 기본 해상도를 2048로 설정 // [수정] 그림자 카메라 범위 최적화

        const d = 30; // 50에서 30으로 줄여서 계산 범위를 좁힘
        mainLight.shadow.camera.left = -d;
        mainLight.shadow.camera.right = d;
        mainLight.shadow.camera.top = d;
        mainLight.shadow.camera.bottom = -d;
        mainLight.shadow.camera.near = 0.5;
        mainLight.shadow.camera.far = 500;

        scene.add(mainLight); // const helper = new THREE.CameraHelper(mainLight.shadow.camera); // scene.add(helper); // [수정] 추가 조명은 그림자를 생성하지 않도록 설정하여 성능 확보

        // (팁) 그림자 범위를 시각적으로 보려면 아래 코드의 주석을 해제하세요.
        spotLight = new THREE.SpotLight(0xffffff, 1.0);
        spotLight.position.set(0, 10, 0);
        spotLight.castShadow = false; // <-- 보조 조명의 그림자는 끔
        scene.add(spotLight);
      }

      function updateLightIntensity(value) {
        const norm = value / 50;
        if (mainLight) mainLight.intensity = norm * 2.4;
        if (fillLight) fillLight.intensity = norm * 1.6;
        if (rimLight) rimLight.intensity = norm * 1.0;
        if (spotLight) spotLight.intensity = norm * 2.0;
      }

      /**
       * Geometry 병합 헬퍼 함수
       * 여러 geometry를 하나로 병합하여 Draw Call 감소
       */
      function mergeGeometries(geometries) {
        if (!geometries || geometries.length === 0) return null;
        if (geometries.length === 1) return geometries[0];

        // BufferGeometryUtils.mergeGeometries 사용
        return BufferGeometryUtils.mergeGeometries(geometries, false);
      }

      /**
       * Material Pool 관리 함수
       * 템플릿별로 재질을 한 번만 생성하고 재사용하여 메모리 사용량 최적화
       */
      function getMaterialsForTemplate(template, templateId = 'default') {
        // 캐시 키 생성 (색상 값으로 고유 키 생성)
        const cacheKey = `${templateId}-${template.pillar.color}-${template.shelf.color}`;

        // 이미 생성된 재질이 있으면 반환
        if (materialPools.rack.has(cacheKey)) {
          return materialPools.rack.get(cacheKey);
        }

        // 새로운 재질 세트 생성
        const materials = {
          pillar: new THREE.MeshStandardMaterial({
            color: template.pillar.color,
            metalness: template.pillar.metalness,
            roughness: template.pillar.roughness,
          }),
          shelf: new THREE.MeshStandardMaterial({
            color: template.shelf.color,
            metalness: template.shelf.metalness,
            roughness: template.shelf.roughness,
          }),
          plate: new THREE.MeshStandardMaterial({
            color: template.shelf.color,
            metalness: 0.1,
            roughness: 0.7,
          }),
        };

        // 캐시에 저장
        materialPools.rack.set(cacheKey, materials);
        return materials;
      }

      /**
       * 셀 재질 가져오기 (전역 공유)
       */
      function getCellMaterials() {
        // 이미 생성되어 있으면 반환
        if (materialPools.cell) {
          return materialPools.cell;
        }

        // 셀 관련 재질 한 번만 생성
        materialPools.cell = {
          transparent: new THREE.MeshBasicMaterial({
            transparent: true,
            opacity: 0.0,
            depthWrite: false,
          }),
          highlightFull: new THREE.MeshBasicMaterial({
            color: 0x00ff00,
            transparent: true,
            opacity: 0.3,
          }),
          highlightEmpty: new THREE.MeshBasicMaterial({
            color: 0xff0000,
            transparent: true,
            opacity: 0.3,
          }),
          highlightGood: new THREE.MeshBasicMaterial({
            color: 0x00ff00,
            transparent: true,
            opacity: 0.3,
          }),
          highlightWarning: new THREE.MeshBasicMaterial({
            color: 0xffaa00,
            transparent: true,
            opacity: 0.3,
          }),
          hoverFull: new THREE.MeshBasicMaterial({
            color: 0x00aaff,
            transparent: true,
            opacity: 0.5,
          }),
          hoverEmpty: new THREE.MeshBasicMaterial({
            color: 0xffaa00,
            transparent: true,
            opacity: 0.5,
          }),
          standard: [
            new THREE.MeshStandardMaterial({ color: 0xffff00, metalness: 0.2, roughness: 0.8 }),
            new THREE.MeshStandardMaterial({ color: 0xffff00, metalness: 0.2, roughness: 0.8 }),
            new THREE.MeshStandardMaterial({ color: 0xffff00, metalness: 0.2, roughness: 0.8 }),
            new THREE.MeshStandardMaterial({ color: 0xffff00, metalness: 0.2, roughness: 0.8 }),
          ],
        };

        return materialPools.cell;
      }

      // 랙을 생성하는 함수. Three.js를 사용해 3D 랙 구조를 생성하고 셀을 추가함
      // rackId: 랙의 고유 ID
      // width, depth, height: 랙의 너비, 깊이, 높이
      // levelCount: 랙의 층 수
      // cellsPerLevel: 각 층의 셀 수
      // preservedCells: 기존 셀 데이터 (기본값 null)
      // isNewRack: 새 랙인지 여부 (기본값 false)
      function createRack(
        rackId,
        width,
        depth,
        height,
        levelCount,
        cellsPerLevel,
        preservedCells = null,
        isNewRack = false,
        templateId = 'default',
        customTemplate = null,
        addToScene = true,
      ) {
        document.getElementById('loading-screen').style.display = 'flex';

        const rackGroup = new THREE.Group();
        rackGroup.userData.isRack = true;
        rackGroup.userData.rackId = rackId;
        rackGroup.userData.internalId = generateUniqueId();
        rackGroup.userData.cells =
          preservedCells ||
          Array.from({ length: levelCount }, () =>
            Array.from({ length: cellsPerLevel }, () => ({})),
          );

        // 템플릿 적용
        const template = customTemplate || rackTemplates[templateId] || rackTemplates['default'];
        rackGroup.userData.config = template.dimensions
          ? { ...template.dimensions }
          : { width, depth, height, levels: levelCount, cells: cellsPerLevel };
        rackGroup.userData.templateId = templateId;

        // 중복 랙 제거 및 관리
        const existingRackIndex = racks.findIndex((r) => r.userData.rackId === rackId);
        if (existingRackIndex !== -1) {
          console.warn(`Rack with ID ${rackId} already exists. Overwriting.`);
          const existingRack = racks[existingRackIndex];
          removeRackCompletely(existingRack);
          racks.splice(existingRackIndex, 1);
        }

        // addToScene이 true이고, rackId가 'temp' 또는 'preview'가 아닌 경우에만 씬과 배열에 추가
        if (addToScene && rackId !== 'temp' && rackId !== 'preview') {
          scene.add(rackGroup);
          racks.push(rackGroup);
        }

        const rackStructureGroup = new THREE.Group();
        rackStructureGroup.name = 'rackStructureGroup';
        rackGroup.add(rackStructureGroup);

        const rackCellGroup = new THREE.Group();
        rackCellGroup.name = 'rackCellGroup';
        rackCellGroup.userData.rackId = rackId;
        rackGroup.add(rackCellGroup);

        const levelHeight = height / levelCount;

        // topPlate에 따라 extraLength와 margin 동적으로 설정
        const extraLength = template.topPlate ? 0.3 : 0.7;
        const pillarHeight = height + extraLength;
        const margin = template.topPlate ? 0 : 0.4;
        const pillarBottomY = pillarHeight / 2;

        // 판 두께 설정
        const plateThickness = template.plateThickness || 0.05;

        // 재료 정의 - Material Pool에서 가져오기 (메모리 최적화)
        const materials = getMaterialsForTemplate(template, templateId);
        const pillarMat = materials.pillar;
        const shelfMat = materials.shelf;
        const plateMat = materials.plate;

        // Geometry 병합 최적화: pillar 구조물 (기둥 + 수평 바)을 하나로 병합
        const pillarGeometries = [];

        // 기둥 geometry 생성 및 배열에 추가
        const pillarGeom = new THREE.BoxGeometry(
          template.pillar.thickness,
          pillarHeight,
          template.pillar.thickness,
        );
        const pillars = [
          { x: -width / 2, z: depth / 2 },
          { x: width / 2, z: depth / 2 },
          { x: -width / 2, z: -depth / 2 },
          { x: width / 2, z: -depth / 2 },
        ];
        pillars.forEach((pos) => {
          const geom = pillarGeom.clone();
          geom.translate(pos.x, pillarBottomY, pos.z);
          pillarGeometries.push(geom);
        });

        // 수평 바 geometry 생성 및 배열에 추가
        const usableHeight = pillarHeight - 2 * margin;
        const adjustedLevelHeight = usableHeight / levelCount;
        const horizBarGeom = new THREE.BoxGeometry(
          template.pillar.thickness,
          template.pillar.thickness,
          depth + template.pillar.thickness,
        );
        for (let i = 0; i <= levelCount; i++) {
          const y = margin + i * adjustedLevelHeight;
          const leftBarGeom = horizBarGeom.clone();
          leftBarGeom.translate(-width / 2, y, 0);
          pillarGeometries.push(leftBarGeom);

          const rightBarGeom = horizBarGeom.clone();
          rightBarGeom.translate(width / 2, y, 0);
          pillarGeometries.push(rightBarGeom);
        }

        // 대각선 보강재도 배열에 추가 (회전 적용 필요)
        if (template.supports.enabled && template.supports.diagonal) {
          for (let i = 0; i < levelCount; i++) {
            const bottomY = margin + i * adjustedLevelHeight;
            const topY = margin + (i + 1) * adjustedLevelHeight;
            const centerY = (bottomY + topY) / 2;
            const diagonalLength = Math.sqrt(adjustedLevelHeight ** 2 + depth ** 2);
            const diagGeom = new THREE.BoxGeometry(
              template.pillar.thickness,
              diagonalLength,
              template.pillar.thickness,
            );
            const angle = Math.atan2(adjustedLevelHeight, depth);
            const rotationX = i % 2 === 0 ? -(Math.PI / 2 - angle) : Math.PI / 2 - angle;

            // 왼쪽 대각선
            const leftDiagGeom = diagGeom.clone();
            leftDiagGeom.rotateX(rotationX);
            leftDiagGeom.translate(-width / 2, centerY, 0);
            pillarGeometries.push(leftDiagGeom);

            // 오른쪽 대각선
            const rightDiagGeom = diagGeom.clone();
            rightDiagGeom.rotateX(rotationX);
            rightDiagGeom.translate(width / 2, centerY, 0);
            pillarGeometries.push(rightDiagGeom);
          }
        }

        // Pillar 구조물 병합 및 mesh 생성
        const mergedPillarGeometry = mergeGeometries(pillarGeometries);
        const pillarStructureMesh = new THREE.Mesh(mergedPillarGeometry, pillarMat);
        pillarStructureMesh.name = 'pillarStructure'; // 그림자 설정을 위한 이름 지정
        // Shadow 최적화: 병합된 pillar 구조물은 그림자 드리움
        pillarStructureMesh.castShadow = renderer.shadowMap.enabled;
        pillarStructureMesh.receiveShadow = false;
        rackStructureGroup.add(pillarStructureMesh);

        // Geometry 병합 최적화: 선반 구조물과 판을 각각 병합
        const shelfGeometries = [];
        const plateGeometries = [];

        for (let i = 0; i < levelCount; i++) {
          const y = i * levelHeight;

          // 선반 프레임 앞
          const frameGeomFront = new THREE.BoxGeometry(
            width - template.shelf.thickness,
            template.shelf.thickness,
            template.shelf.thickness,
          );
          const frontGeom = frameGeomFront.clone();
          frontGeom.translate(0, y + 0.3, depth / 2 - template.shelf.thickness);
          shelfGeometries.push(frontGeom);

          // 선반 프레임 뒤
          const frameGeomBack = new THREE.BoxGeometry(
            width - template.shelf.thickness,
            template.shelf.thickness,
            template.shelf.thickness,
          );
          const backGeom = frameGeomBack.clone();
          backGeom.translate(0, y + 0.3, -depth / 2 + template.shelf.thickness);
          shelfGeometries.push(backGeom);

          // 선반 프레임 좌우
          const frameGeomSide = new THREE.BoxGeometry(
            template.shelf.thickness,
            template.shelf.thickness,
            depth - template.shelf.thickness,
          );
          const leftGeom = frameGeomSide.clone();
          leftGeom.translate(-width / 2 + template.shelf.thickness, y + 0.3, 0);
          shelfGeometries.push(leftGeom);

          const rightGeom = frameGeomSide.clone();
          rightGeom.translate(width / 2 - template.shelf.thickness, y + 0.3, 0);
          shelfGeometries.push(rightGeom);

          // 서포트
          if (template.supports.enabled) {
            for (let j = 1; j < 5; j++) {
              const supportGeom = new THREE.BoxGeometry(
                0.08,
                0.08,
                depth - template.shelf.thickness,
              );
              const suppGeom = supportGeom.clone();
              suppGeom.translate(-width / 2 + (width / 5) * j, y + 0.3, 0);
              shelfGeometries.push(suppGeom);
            }
          }

          // 선반 위 판
          if (template.shelfPlate) {
            const plateGeom = new THREE.BoxGeometry(
              width - template.shelf.thickness * 2,
              plateThickness,
              depth - template.shelf.thickness * 2,
            );
            const plGeom = plateGeom.clone();
            plGeom.translate(0, y + 0.3 + template.shelf.thickness / 2 + plateThickness / 2, 0);
            plateGeometries.push(plGeom);
          }
        }

        // 랙 상단 판 추가
        if (template.topPlate) {
          const topPlateGeom = new THREE.BoxGeometry(width, plateThickness, depth);
          const topGeom = topPlateGeom.clone();
          topGeom.translate(0, pillarHeight - plateThickness / 2, 0);
          plateGeometries.push(topGeom);
        }

        // Shelf 구조물 병합 및 mesh 생성
        if (shelfGeometries.length > 0) {
          const mergedShelfGeometry = mergeGeometries(shelfGeometries);
          const shelfStructureMesh = new THREE.Mesh(mergedShelfGeometry, shelfMat);
          shelfStructureMesh.name = 'shelfStructure'; // 그림자 설정을 위한 이름 지정
          // Shadow 최적화: 선반 구조물은 그림자 끔
          shelfStructureMesh.castShadow = false;
          shelfStructureMesh.receiveShadow = false;
          rackStructureGroup.add(shelfStructureMesh);
        }

        // Plate 병합 및 mesh 생성
        if (plateGeometries.length > 0) {
          const mergedPlateGeometry = mergeGeometries(plateGeometries);
          const plateStructureMesh = new THREE.Mesh(mergedPlateGeometry, plateMat);
          plateStructureMesh.name = 'plateStructure'; // 그림자 설정을 위한 이름 지정
          // Shadow 최적화: 판은 그림자 받기만 (받는 표면)
          plateStructureMesh.castShadow = false;
          plateStructureMesh.receiveShadow = renderer.shadowMap.enabled;
          rackStructureGroup.add(plateStructureMesh);
        }

        // 셀 생성
        createCellInteractions(
          rackCellGroup,
          width,
          depth,
          height,
          levelCount,
          cellsPerLevel,
          rackGroup.userData.cells,
        );

        // BoundingBox 계산 및 Shadow 최적화
        rackGroup.traverse((child) => {
          if (child.isMesh) {
            // BoundingBox 계산
            if (child.geometry) child.geometry.computeBoundingBox();

            // Shadow 최적화: 개별 부품에서 이미 설정했으므로 여기서는 설정하지 않음
            // 기둥만 castShadow = true, 판은 receiveShadow = true로 이미 설정됨
          }
        });

        rackGroup.updateMatrixWorld(true);

        const bbox = new THREE.Box3().setFromObject(rackGroup);
        const minY = bbox.min.y;
        if (minY < 0) rackGroup.position.y -= minY;

        document.getElementById('loading-screen').style.display = 'none';
        return rackGroup;
      }

      /**
       * 노란 파렛트 Mesh를 생성해 반환하는 함수
       * 실제 산업용 파렛트와 다를 수 있으므로, 적절히 수정하세요.
       */
      function createYellowPallet(width, depth) {
        // (예시) 파렛트 두께는 0.15 정도, 상하 오픈형을 단순화해서 BoxGeometry만 사용
        const palletHeight = 0.15;

        // 텍스처 사용 시 (이미지 경로가 있을 경우):
        // const texture = new THREE.TextureLoader().load('경로/또는/URL');
        // const material = new THREE.MeshStandardMaterial({ map: texture, ... });

        // 텍스처 대신 단색 노란색
        const material = new THREE.MeshStandardMaterial({
          color: 0xffd400, // 노란색 계열
          metalness: 0.2,
          roughness: 0.7,
        });

        // 파렛트 크기는 랙의 width, depth와 비슷하게 맞추거나, 약간 작게 해도 됨
        const geometry = new THREE.BoxGeometry(width * 0.95, palletHeight, depth * 0.95);
        const palletMesh = new THREE.Mesh(geometry, material);

        // 파렛트가 지면 위에 놓이도록 Y 위치를 살짝 올림
        // (랙 바닥이 0에 맞춰지므로, 파렛트 두께의 절반만큼)
        palletMesh.position.set(0, palletHeight / 2, 0);

        // 그림자 옵션 (renderer 상태에 따라 설정)
        palletMesh.castShadow = renderer.shadowMap.enabled;
        palletMesh.receiveShadow = renderer.shadowMap.enabled;

        return palletMesh;
      }

      function createCellInteractions(
        parentRack,
        width,
        depth,
        height,
        levelCount,
        cellsPerLevel,
        rackCells,
      ) {
        if (!levelCount || isNaN(levelCount) || levelCount < 1) levelCount = 1;
        if (!cellsPerLevel || isNaN(cellsPerLevel) || cellsPerLevel < 1) cellsPerLevel = 1;

        const rackId = parentRack.userData.rackId || 'Rack-Unknown';
        const cellContainer = new THREE.Group();
        cellContainer.name = 'cellContainer';
        cellContainer.userData.isCellContainer = true;
        cellContainer.userData.rackId = rackId;
        parentRack.add(cellContainer);

        const rowHeight = height / levelCount;
        const colWidth = width / cellsPerLevel;
        const cellHeight = 0.9;

        // 재질 정의 - Material Pool에서 가져오기 (메모리 최적화)
        const cellMats = getCellMaterials();
        const transparentMaterial = cellMats.transparent;
        const highlightMaterialFull = cellMats.highlightFull;
        const highlightMaterialEmpty = cellMats.highlightEmpty;
        const highlightMaterialGood = cellMats.highlightGood;
        const highlightMaterialWarning = cellMats.highlightWarning;
        const hoverMaterialFull = cellMats.hoverFull;
        const hoverMaterialEmpty = cellMats.hoverEmpty;
        const standardMaterials = cellMats.standard;
        const boxGeometry = new THREE.BoxGeometry(colWidth * 0.8, 0.7, depth * 0.8);

        // 셀 데이터 크기 조정
        let newCells = [];
        for (let row = 0; row < levelCount; row++) {
          newCells[row] = [];
          for (let col = 0; col < cellsPerLevel; col++) {
            const oldRowData = rackCells[row] || [];
            const oldCellData = oldRowData[col] || {};
            newCells[row][col] = { ...oldCellData };
          }
        }
        parentRack.parent.userData.cells = newCells;

        // 셀 생성 (posY 수정)
        for (let row = 0; row < levelCount; row++) {
          const posY = row * rowHeight + 0.1 + cellHeight / 2 + 0.1; // 셀을 0.1 단위 내림
          for (let col = 0; col < cellsPerLevel; col++) {
            const posX = col * colWidth - width / 2 + colWidth / 2;
            const cellData = newCells[row][col];
            const cellId = `${rackId}-${String.fromCharCode(65 + row)}${col + 1}`;

            const cellGeometry = new THREE.BoxGeometry(colWidth * 0.9, cellHeight, depth * 0.9);
            const cellMesh = new THREE.Mesh(cellGeometry, transparentMaterial.clone());
            cellMesh.position.set(posX, posY, 0);
            cellMesh.userData.cellId = cellId;
            cellMesh.userData.rackId = rackId;
            cellMesh.userData.isCell = true;
            cellMesh.userData.level = row;
            cellMesh.userData.cellIndex = col;
            cellMesh.userData.cellData = { ...cellData };
            cellMesh.userData.originalMaterial = cellMesh.material;

            if (!cellMesh.userData.cellData.hasMaterial) {
              cellMesh.visible = false;
              cellMesh.material.opacity = 0.0;
              //cellMesh.material.transparent = true;
            } else {
              const material = standardMaterials[col % standardMaterials.length];
              const boxMesh = new THREE.Mesh(boxGeometry, material);
              boxMesh.position.copy(cellMesh.position);
              cellContainer.add(boxMesh);
              cellMesh.userData.contentMesh = boxMesh;

              const sprite = createCellLabel(cellMesh.userData.cellData, posX, posY + 0.5, 0);
              sprite.userData = { rackId: rackId, cellId: cellId };
              cellContainer.add(sprite);
              labelSprites.push(sprite);
            }

            // Material Pool의 재질을 직접 참조 (clone 불필요, 메모리 최적화)
            cellMesh.userData.highlightMaterial = cellMesh.userData.cellData.hasMaterial
              ? highlightMaterialFull
              : highlightMaterialEmpty;
            cellMesh.userData.hoverMaterial = cellMesh.userData.cellData.hasMaterial
              ? hoverMaterialFull
              : hoverMaterialEmpty;
            cellMesh.userData.statusMaterial =
              cellMesh.userData.cellData.hasMaterial &&
              cellMesh.userData.cellData.status === '점검 필요'
                ? highlightMaterialWarning
                : highlightMaterialGood;

            cellContainer.add(cellMesh);
            cellMeshes.push(cellMesh);
          }
        }
        // updateHighlightMode();
      }

      // 왼쪽 패널의 "랙 추가" 버튼 이벤트
      document.getElementById('add-rack-left-panel').addEventListener('click', async () => {
        const rackId = sanitizeInput(document.getElementById('rack-id').value.trim());
        const templateId = selectedTemplateId; // 선택된 템플릿 ID 사용
        const template = rackTemplates[templateId];
        const width =
          template.dimensions?.width ||
          parseFloat(document.getElementById('rack-width').value) ||
          5;
        const depth =
          template.dimensions?.depth ||
          parseFloat(document.getElementById('rack-depth').value) ||
          1.5;
        const height =
          template.dimensions?.height ||
          parseFloat(document.getElementById('rack-height').value) ||
          5;
        const levels =
          template.dimensions?.levels ||
          parseInt(document.getElementById('rack-levels').value) ||
          5;
        const cells =
          template.dimensions?.cells || parseInt(document.getElementById('rack-cells').value) || 4;
        const rotationDeg = parseFloat(document.getElementById('rack-rotation').value) || 0;
        const rotationRad = THREE.MathUtils.degToRad(rotationDeg);

        if (!rackId) {
          alert('랙 또는 파렛트 아이디를 입력하세요.');
          return;
        }

        const groupName = document.getElementById('cfg-group').value;

        if (templateId === 'yellowPallet') {
          // 파렛트 추가 로직
          if (pallets.some((p) => p.userData.palletId === rackId)) {
            alert('이미 존재하는 파렛트 아이디입니다. 다른 아이디를 입력하세요.');
            return;
          }

          const newPallet = createPallet(rackId, templateId);
          newPallet.rotation.y = rotationRad;

          const offsetX = 6;
          let maxX = pallets.length > 0 ? Math.max(...pallets.map((p) => p.position.x)) : 0;
          newPallet.position.set(
            maxX + offsetX,
            floorMesh ? floorMesh.position.y + newPallet.userData.config.height / 2 : 0.075,
            0,
          );

          pallets.push(newPallet);
          scene.add(newPallet);
          saveAllRackConfigs();
        } else {
          // 기존 랙 추가 로직
          if (racks.some((r) => r.userData.rackId === rackId)) {
            alert('이미 존재하는 랙 아이디입니다. 다른 아이디를 입력하세요.');
            return;
          }

          const floorTopY = floorMesh.position.y + floorMesh.geometry.parameters.height / 2;

          const newRack = createRack(
            rackId,
            width,
            depth,
            height,
            levels,
            cells,
            null,
            true,
            templateId,
          );
          newRack.userData.config.group = groupName;
          newRack.rotation.y = rotationRad;
          newRack.userData.config.rotation = rotationDeg;
          newRack.userData.templateId = templateId;

          const offsetX = 6;
          let maxX = racks.length > 0 ? Math.max(...racks.map((r) => r.position.x)) : 0;
          newRack.position.set(maxX + offsetX, floorTopY, 0);

          racks.push(newRack);
          scene.add(newRack);

          // addOuterSquareBorder(newRack, {
          //   margin: 0.3,
          //   height: 0.02,
          //   lineWidth: 4, // 테두리 두께를 5cm로 고정
          //   color: 0xffff00,
          // });

          await loadDataAndMapForRack(newRack);
          saveAllRackConfigs();
        }
      });

      // Add save template button listener
      document.getElementById('save-template').addEventListener('click', saveRackTemplate);

      function createCellLabel(cellData, x, y, z) {
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.width = 256;
        canvas.height = 128;
        context.fillStyle = 'rgba(0, 0, 0, 0.6)';
        context.fillRect(0, 0, canvas.width, canvas.height);
        context.fillStyle = 'white';
        context.font = '24px Arial';
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        let text = cellData.materialId || '';
        context.fillText(text, canvas.width / 2, canvas.height / 2 - 20);
        text = cellData.name || '';
        context.fillText(text, canvas.width / 2, canvas.height / 2 + 20);
        const texture = new THREE.CanvasTexture(canvas);
        const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true });
        const sprite = new THREE.Sprite(spriteMaterial);
        sprite.position.set(x, y, z);
        sprite.scale.set(1.5, 0.75, 1);
        sprite.visible = false;
        // Store texture reference for cleanup
        sprite.userData.texture = texture;
        sprite.userData.material = spriteMaterial;
        labelSprites.push(sprite);
        return sprite;
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function clearSelectedPallets() {
        selectedPalletHelpers.forEach((helperObj) => scene.remove(helperObj.helper));
        selectedPalletHelpers = [];
        selectedPallets = [];
      }

      function onMouseClick(event) {
        // 툴바 또는 그 하위 요소를 클릭한 경우 무시
        if (event.target.closest('#rack-toolbar')) return;
        // 우측 패널 내 클릭도 무시
        if (event.target.closest('#rack-config-panel')) return;

        // 클릭 위치가 원점 근처면 무시
        if (Math.sqrt(event.clientX ** 2 + event.clientY ** 2) < 5) return;

        // 마우스 NDC 변환
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);

        if (editMode) {
          // 1) 랙 선택 처리
          const visibleRacks = racks.filter((r) => r.visible);
          let intersects = raycaster.intersectObjects(visibleRacks, true);
          if (intersects.length > 0) {
            let obj = intersects[0].object;
            // 최상위 랙 그룹 찾기
            while (obj.parent && !obj.userData.isRack) {
              obj = obj.parent;
            }
            if (!obj.userData.rackId) {
              console.warn('선택된 객체에 rackId가 없습니다:', obj);
              return;
            }

            if (event.shiftKey) {
              // Shift+클릭: 다중 선택
              const idx = selectedRacks.indexOf(obj);
              if (idx === -1) {
                selectedRacks.push(obj);
                const structure = obj.getObjectByName('rackStructureGroup') || obj;
                const helper = new THREE.BoxHelper(structure, RACK_HELPER_COLOR);
                scene.add(helper);
                selectedRackHelpers.push({ rack: obj, helper });
              } else {
                const helperObj = selectedRackHelpers.find((h) => h.rack === obj);
                if (helperObj) {
                  scene.remove(helperObj.helper);
                  selectedRackHelpers = selectedRackHelpers.filter((h) => h.rack !== obj);
                }
                selectedRacks.splice(idx, 1);
              }
            } else {
              // 단일 선택
              clearSelectedRacks();
              //clearSelectedPallets();
              selectedRacks.push(obj);
              const structure = obj.getObjectByName('rackStructureGroup') || obj;
              const helper = new THREE.BoxHelper(structure, RACK_HELPER_COLOR);
              scene.add(helper);
              selectedRackHelpers.push({ rack: obj, helper });

              // 툴바 표시
              // if (selectedRacks.length === 1) {
              //   showRackToolbar(obj);
              // } else {
              //   hideRackToolbar();
              // }
            }

            // 선택된 랙이 하나일 때만 우측 패널에 값 채우기
            if (selectedRacks.length === 1) {
              const rackObj = selectedRacks[0];
              const cfg = rackObj.userData.config;

              // 1) 오른쪽 패널 보이기
              const panel = document.getElementById('rack-config-panel');
              panel.classList.remove('hidden');

              // 2) 패널 필드에 현재 랙 설정값 채우기
              document.getElementById('cfg-rack-id').value = rackObj.userData.rackId;
              document.getElementById('cfg-width').value = cfg.width;
              document.getElementById('cfg-depth').value = cfg.depth;
              document.getElementById('cfg-height').value = cfg.height;
              document.getElementById('cfg-levels').value = cfg.levels;
              document.getElementById('cfg-cells').value = cfg.cells;
              document.getElementById('cfg-rotation-value').value = cfg.rotation;
              document.getElementById('cfg-group-select').value = cfg.group || '기본';

              // (기존 툴바 inputs 동기화)
              if (toolbarInputs.rackId) {
                toolbarInputs.rackId.value = rackObj.userData.rackId;
                toolbarInputs.width.value = cfg.width;
                toolbarInputs.depth.value = cfg.depth;
                toolbarInputs.height.value = cfg.height;
                toolbarInputs.levels.value = cfg.levels;
                toolbarInputs.cells.value = cfg.cells;
                toolbarInputs.rotation.value = cfg.rotation;
                if (toolbarInputs.group) {
                  toolbarInputs.group.value = cfg.group || '기본';
                }
              }
            } else {
              // 다중 선택 또는 선택 해제 시
              document.getElementById('rack-id').value = '다수 선택됨';
              hideRackToolbar();
            }

            return;
          }

          // 2) 랙이 아닌 경우 파렛트 선택 처리
          intersects = raycaster.intersectObjects(pallets, true);
          if (intersects.length > 0) {
            let obj = intersects[0].object;
            while (obj.parent && !obj.userData.palletId) {
              obj = obj.parent;
            }
            if (!obj.userData.palletId) {
              console.warn('선택된 객체에 palletId가 없습니다:', obj);
              return;
            }

            if (event.shiftKey) {
              const idx = selectedPallets.indexOf(obj);
              if (idx === -1) {
                selectedPallets.push(obj);
                const helper = new THREE.BoxHelper(obj, 0xffff00);
                scene.add(helper);
                selectedPalletHelpers.push({ pallet: obj, helper });
              } else {
                const helperObj = selectedPalletHelpers.find((h) => h.pallet === obj);
                if (helperObj) {
                  scene.remove(helperObj.helper);
                  selectedPalletHelpers = selectedPalletHelpers.filter((h) => h.pallet !== obj);
                }
                selectedPallets.splice(idx, 1);
              }
            } else {
              clearSelectedRacks();
              clearSelectedPallets();
              selectedPallets.push(obj);
              const helper = new THREE.BoxHelper(obj, 0xffff00);
              scene.add(helper);
              selectedPalletHelpers.push({ pallet: obj, helper });
            }
            console.log('선택된 파렛트:', obj.userData.palletId);
            return;
          }

          // 3) 랙/파렛트 모두 선택되지 않으면 해제
          clearSelectedRacks();
          clearMeasurementVisuals();
          clearSelectedPallets();
          hideRackToolbar();
          if (racks.length > 0 || pallets.length > 0) saveAllRackConfigs();
          return;
        }

        // 편집 모드가 아닐 때: 셀 클릭 → 우측 셀 정보 패널
        const cellInts = raycaster.intersectObjects(cellMeshes, true);
        if (cellInts.length > 0) {
          const cell = cellInts[0].object;
          const d = cell.userData.cellData || {};
          document.getElementById('cell-info-id').textContent = cell.userData.cellId;
          document.getElementById('cell-info-materialId').textContent = d.materialId || '–';
          document.getElementById('cell-info-name').textContent = d.name || '–';
          document.getElementById('cell-info-qty').textContent =
            d.quantity != null ? d.quantity : '0';
          document.getElementById('cell-info-panel').classList.remove('hidden');
        } else {
          document.getElementById('cell-info-panel').classList.add('hidden');
        }
      }

      function createPallet(palletId, templateId = 'yellowPallet') {
        const template = rackTemplates[templateId];
        if (!template) return null;

        const palletWidth = template.dimensions?.width || 1.2;
        const palletDepth = template.dimensions?.depth || 1.2;
        const palletHeight = 0.15; // 파렛트 고정 높이

        const palletGroup = new THREE.Group();

        const palletGeometry = new THREE.BoxGeometry(palletWidth, palletHeight, palletDepth);
        const palletMaterial = new THREE.MeshStandardMaterial({
          color: template.shelf.color || 0xffff00, // 노란색 기본값
          metalness: template.shelf.metalness || 0.2,
          roughness: template.shelf.roughness || 0.6,
        });
        const palletMesh = new THREE.Mesh(palletGeometry, palletMaterial);
        palletMesh.position.y = palletHeight / 2;
        palletMesh.castShadow = true;
        palletMesh.receiveShadow = true;

        palletGroup.add(palletMesh);
        palletGroup.userData = {
          palletId: palletId,
          templateId: templateId,
          config: { width: palletWidth, depth: palletDepth, height: palletHeight },
        };

        return palletGroup;
      }

      function clearSelectedRacks() {
        selectedRackHelpers.forEach((helperObj) => scene.remove(helperObj.helper));
        selectedRackHelpers = [];
        selectedRacks = [];
      }

      function selectRack(rackObj) {
        if (selectedRackHelper) {
          scene.remove(selectedRackHelper);
          selectedRackHelper = null;
        }
        selectedRack = rackObj;
        if (editMode) {
          selectedRackHelper = new THREE.BoxHelper(selectedRack, 0xffff00);
          scene.add(selectedRackHelper);
        }
        // selectedRacks를 여기서 수정하지 않도록 주의
        if (selectedRack.userData.config) {
          const config = selectedRack.userData.config;
          document.getElementById('rack-width').value = config.width;
          document.getElementById('rack-depth').value = config.depth;
          document.getElementById('rack-height').value = config.height;
          document.getElementById('rack-levels').value = config.levels;
          document.getElementById('rack-cells').value = config.cells;
        }
        document.getElementById('rack-id').value = selectedRack.userData.rackId;
        const currentRotationDeg = THREE.MathUtils.radToDeg(selectedRack.rotation.y);
        document.getElementById('rack-rotation').value = currentRotationDeg;
        document.getElementById('rack-rotation-num').value = currentRotationDeg;
      }

      function applyCellHover(cell) {
        // hover용 머티리얼 적용
        cell.material = cell.userData.hoverMaterial;
        if (!cell.userData.cellData.hasMaterial) {
          cell.castShadow = false;
          cell.receiveShadow = false;
        } else {
          // 물건 있는 셀은 기존 그림자 설정 유지
          cell.castShadow = true;
          cell.receiveShadow = true;
        }
        // contentMesh도 살짝 키우기
        if (cell.userData.contentMesh) {
          cell.userData.contentMesh.scale.set(1.1, 1.1, 1.1);
        }
        // 툴팁 띄우기
        // updateTooltip(cell, lastMouseX, lastMouseY);
      }

      function resetCellHover(cell) {
        // 원래 머티리얼 복원
        cell.material = cell.userData.originalMaterial;

        // 그림자 설정도 원복
        cell.castShadow = true;
        cell.receiveShadow = true;

        if (cell.userData.contentMesh) {
          cell.userData.contentMesh.scale.set(1, 1, 1);
        }
        tooltip.style.display = 'none';
      }

      function updateTooltip(cell, x, y) {
        const cellData = cell.userData.cellData || { hasMaterial: false };

        // 세련된 툴팁 구조
        let tooltipContent = `<div class="tooltip-header">${
          cell.userData.cellId || '셀 정보'
        }</div>`;

        if (cellData.hasMaterial) {
          tooltipContent += `
            <div class="tooltip-row">
              <span class="tooltip-label">품목코드</span>
              <span class="tooltip-value">${cellData.materialId || '정보 없음'}</span>
            </div>
            <div class="tooltip-row">
              <span class="tooltip-label">자재명</span>
              <span class="tooltip-value">${cellData.name || '정보 없음'}</span>
            </div>
            <div class="tooltip-row">
              <span class="tooltip-label">수량</span>
              <span class="tooltip-value">${cellData.quantity || 0}개</span>
            </div>
          `;
        } else {
          tooltipContent += `<div class="tooltip-empty">빈 셀</div>`;
        }

        tooltip.innerHTML = tooltipContent;
        tooltip.style.left = x + 15 + 'px';
        tooltip.style.top = y + 15 + 'px';
        tooltip.style.display = 'block';
      }

      // function updateHighlightMode() {
      //   const mode = highlightModeSelect.value;
      //   cellMeshes.forEach((mesh) => {
      //     if (mesh === hoveredCell) return;
      //     mesh.material = mesh.userData.originalMaterial;
      //     if (mode === 'empty' && !mesh.userData.cellData.hasMaterial) {
      //       mesh.material = mesh.userData.highlightMaterial;
      //     } else if (mode === 'full' && mesh.userData.cellData.hasMaterial) {
      //       mesh.material = mesh.userData.highlightMaterial;
      //     } else if (mode === 'status' && mesh.userData.cellData.hasMaterial) {
      //       mesh.material = mesh.userData.statusMaterial;
      //       if (mesh.userData.contentMesh) {
      //         if (mesh.userData.cellData.status === '점검 필요') {
      //           if (!mesh.userData.originalContentMaterial) {
      //             mesh.userData.originalContentMaterial =
      //               mesh.userData.contentMesh.material.clone();
      //           }
      //           mesh.userData.contentMesh.material.emissive.set(0xff5500);
      //           mesh.userData.contentMesh.material.emissiveIntensity = 0.3;
      //         } else {
      //           if (mesh.userData.originalContentMaterial) {
      //             mesh.userData.contentMesh.material = mesh.userData.originalContentMaterial;
      //           }
      //         }
      //       }
      //     } else {
      //       if (mesh.userData.contentMesh && mesh.userData.originalContentMaterial) {
      //         mesh.userData.contentMesh.material = mesh.userData.originalContentMaterial;
      //         mesh.userData.originalContentMaterial = null;
      //       }
      //     }
      //   });
      // }

      function updateRotationSpeed() {
        rotationSpeed = parseFloat(rotationSpeedInput.value);
        autoRotate = rotationSpeed > 0;
      }

      function updateShadowQuality() {
        const quality = isEditMode
          ? document.querySelector('input[name="shadowQuality"]:checked')?.value || 'medium'
          : 'low'; // 뷰어 모드 강제 low

        const sizes = { low: 1024, medium: 2048, high: 4096 };
        const size = sizes[quality];
        mainLight.shadow.mapSize.set(size, size);
        if (mainLight.shadow.map) {
          mainLight.shadow.map.dispose();
          mainLight.shadow.map = null;
        }
        mainLight.shadow.needsUpdate = true;
      }

      function toggleLabels() {
        labelsVisible = !labelsVisible;
        labelSprites.forEach((s) => (s.visible = labelsVisible && !isEditMode));
      }

      function addRacks(quantity) {
        const offsetX = 6;
        let maxX = -Infinity;
        racks.forEach((rack) => {
          if (rack.position.x > maxX) {
            maxX = rack.position.x;
          }
        });
        if (maxX === -Infinity) {
          maxX = 0;
        }
        for (let i = 1; i <= quantity; i++) {
          let newRack = createRack(5, 1.5, 5, 5, 4);
          newRack.position.x = maxX + i * offsetX;
        }
      }

      // ★★★ 구성 변경 시 이전 구성의 셀 및 라벨 등 제거 (수정됨) ★★★
      function removeOldRackElements(rack) {
        // rack이 유효한지 먼저 확인
        if (!rack || typeof rack.traverse !== 'function') return;

        rack.traverse((child) => {
          // isCell 플래그로 셀 판별
          if (child.userData && child.userData.isCell) {
            if (child.parent) {
              child.parent.remove(child);
            }
            // geometry, material dispose
            if (child.geometry) {
              child.geometry.dispose();
            }
            if (child.material) {
              if (Array.isArray(child.material)) {
                child.material.forEach((m) => m.dispose());
              } else {
                child.material.dispose();
              }
            }
          }
        });

        // 전역 배열에서도 제거
        cellMeshes = cellMeshes.filter((mesh) => mesh.userData.rackId !== rack.userData.rackId);
        labelSprites = labelSprites.filter((sprite) => {
          return !(sprite.userData && sprite.userData.rackId === rack.userData.rackId);
        });

        // 혹시 떠 있는 툴팁 숨기기
        tooltip.style.display = 'none';
      }

      // 실시간 업데이트 함수: 기존 applySelectedRackConfig와 동일한 로직을 사용
      function removeRackCompletely(rack) {
        // 해당 랙에 속한 모든 자식(셀 컨테이너 포함)을 순회하며 자원을 해제
        rack.traverse((child) => {
          if (child.geometry) child.geometry.dispose();
          if (child.material) {
            if (Array.isArray(child.material)) {
              child.material.forEach((m) => m.dispose());
            } else {
              child.material.dispose();
            }
          }
        });
        // 전역 셀/라벨 정리
        clearGlobalCellsForRack(rack.userData.rackId);
        // 씬에서 제거
        if (rack.parent) {
          rack.parent.remove(rack);
        }
        // (필요시) 참조 null 처리
      }

      // 업데이트 함수 – 선택된 랙의 구성 변경 시 ghost cell 문제를 완전히 제거한 후 새로 생성
      // ── Realtime single‐rack update (drag/move) ──
      async function updateSelectedRackConfigRealtime() {
        if (!selectedRacks.length) return;

        const newSelectedRacks = [];
        const newSelectedRackHelpers = [];

        // remove old helpers
        selectedRackHelpers.forEach((h) => scene.remove(h.helper));
        selectedRackHelpers = [];

        for (const oldRack of selectedRacks) {
          const rackId = oldRack.userData.rackId;
          const oldPos = oldRack.position.clone();
          const oldGroup = oldRack.userData.config.group || '기본';
          const preserved = oldRack.userData.cells.map((row, i) =>
            row.map((c, j) => `${rackId}-${String.fromCharCode(65 + i)}${j + 1}`),
          );

          // tear out
          removeRackCompletely(oldRack);
          racks = racks.filter((r) => r.userData.rackId !== rackId);

          // recreate
          const newRack = createRack(
            rackId,
            parseFloat(document.getElementById('rack-width').value),
            parseFloat(document.getElementById('rack-depth').value),
            parseFloat(document.getElementById('rack-height').value),
            parseInt(document.getElementById('rack-levels').value, 10),
            parseInt(document.getElementById('rack-cells').value, 10),
          );
          newRack.position.copy(oldPos);
          newRack.rotation.y = THREE.MathUtils.degToRad(
            parseFloat(document.getElementById('rack-rotation').value),
          );
          // ***** preserve the group *****
          newRack.userData.config.group = oldGroup;

          // re‐map data
          await loadDataAndMapForRack(newRack, preserved);

          racks.push(newRack);
          newSelectedRacks.push(newRack);

          if (editMode) {
            const h = new THREE.BoxHelper(
              newRack.getObjectByName('rackStructureGroup') || newRack,
              0xc4ff2e,
            );
            scene.add(h);
            newSelectedRackHelpers.push({ rack: newRack, helper: h });
          }
        }

        selectedRacks = newSelectedRacks;
        selectedRackHelpers = newSelectedRackHelpers;
        saveAllRackConfigs();
      }

      // async function applyAllRackConfig() {
      //   const width = parseFloat(document.getElementById('rack-width').value) || 5;
      //   const depth = parseFloat(document.getElementById('rack-depth').value) || 1.5;
      //   const height = parseFloat(document.getElementById('rack-height').value) || 5;
      //   const levels = parseInt(document.getElementById('rack-levels').value) || 5;
      //   const cells = parseInt(document.getElementById('rack-cells').value) || 4;
      //   const rotationDeg = parseFloat(document.getElementById('rack-rotation').value) || 0;
      //   const rotationRad = THREE.MathUtils.degToRad(rotationDeg);

      //   const newRacks = [];
      //   const processedRackIds = new Set();

      //   for (const oldRack of racks) {
      //     const rackId = oldRack.userData.rackId;
      //     if (processedRackIds.has(rackId)) continue;

      //     const pos = oldRack.position.clone();
      //     const preservedCellAddresses = oldRack.userData.cells.map((row, rowIdx) =>
      //       row.map((cell, colIdx) => `${rackId}-${String.fromCharCode(65 + rowIdx)}${colIdx + 1}`),
      //     );

      //     removeRackCompletely(oldRack);
      //     const newRack = createRack(rackId, width, depth, height, levels, cells);
      //     newRack.position.copy(pos);
      //     newRack.rotation.y = rotationRad;
      //     newRack.userData.config = { width, depth, height, levels, cells, rotation: rotationDeg };
      //     newRack.updateMatrixWorld(true);

      //     await loadDataAndMapForRack(newRack, preservedCellAddresses);

      //     scene.add(newRack);

      //     newRacks.push(newRack);
      //     processedRackIds.add(rackId);
      //   }

      //   racks = newRacks;
      //   clearSelectedRacks();
      //   saveAllRackConfigs();
      //   updateRackUI(rotationDeg);
      //   renderer.render(scene, camera);
      // }

      function showMaterialModal(cell) {
        const cellData = cell.userData.cellData;

        // "셀 위치"를 cell.userData.cellId로 표시
        document.getElementById('cell-position').textContent = cell.userData.cellId;

        document.getElementById('material-id').textContent = cellData.materialId || '';
        document.getElementById('material-name').textContent = cellData.name || '';
        document.getElementById('material-quantity').textContent = (cellData.quantity || 0) + ' 개';
        document.getElementById('material-date').textContent = cellData.date || '';
        document.getElementById('material-status').textContent = cellData.status || '양호';

        // 모달 표시
        document.getElementById('material-modal').style.display = 'block';
      }

      // 디바운싱 적용 (기존 코드 유지)
      const debouncedUpdate = debounce(updateSelectedRackConfigRealtime, 300);

      document
        .querySelectorAll(
          '#rack-width, #rack-depth, #rack-height, #rack-levels, #rack-cells, #rack-rotation, #rack-rotation-num',
        )
        .forEach((input) => {
          input.removeEventListener('input', updateSelectedRackConfigRealtime); // 기존 리스너 제거
          input.addEventListener('input', debouncedUpdate); // 디바운싱된 리스너 추가
        });

      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }

      // 문자 열(A/B/C/...) → 0-based 인덱스 변환 헬퍼
      function columnLetterToIndex(letter) {
        return letter.toUpperCase().charCodeAt(0) - 65;
      }

      // 전역 변수로 rack.json 데이터를 캐싱
      let cachedRackData = null;

      async function loadDataAndMapForRack(rack, cellAddresses = null) {
        try {
          // 캐시된 데이터가 없으면 fetch로 파일 읽기
          if (!cachedRackData) {
            const response = await fetch('/static/data/racks.json');
            if (!response.ok) {
              throw new Error(`Failed to load rack data: ${response.status}`);
            }
            cachedRackData = await response.json();
          }
          const dataList = cachedRackData;

          const rackId = rack.userData.rackId;
          const levels = rack.userData.config.levels;
          const cellsPerLevel = rack.userData.config.cells;

          // 셀 데이터 초기화 확인
          if (
            !rack.userData.cells ||
            rack.userData.cells.length !== levels ||
            (rack.userData.cells[0] && rack.userData.cells[0].length !== cellsPerLevel)
          ) {
            rack.userData.cells = Array.from({ length: levels }, () =>
              Array.from({ length: cellsPerLevel }, () => ({})),
            );
          }

          console.log(`loadDataAndMapForRack: rackId=${rackId}, cellAddresses=`, cellAddresses);

          dataList.forEach((item) => {
            const { Location, itemCode, itemName, Now_Qty, In_day } = item;
            const parts = Location.split('-');
            if (parts.length < 3) return;
            // 예를 들어 "F-01" 형식이면 parts[0]-parts[1]으로 구성
            const targetRackId = `${parts[0]}-${parts[1]}`;
            if (targetRackId !== rackId) return;

            const levelLetter = parts[2].charAt(0).toUpperCase();
            const cellNum = parseInt(parts[2].substring(1), 10);
            const rowIndex = levelLetter.charCodeAt(0) - 65;
            const colIndex = cellNum - 1;

            if (rowIndex >= levels || colIndex >= cellsPerLevel || rowIndex < 0 || colIndex < 0) {
              //console.warn(`Invalid cell index: ${Location}, rowIndex=${rowIndex}, colIndex=${colIndex}`);
              return;
            }

            const cellAddress = `${rackId}-${levelLetter}${cellNum}`;
            // cellAddresses가 유효하면 해당 주소와 일치하는 셀만 업데이트
            if (
              cellAddresses &&
              Array.isArray(cellAddresses) &&
              Array.isArray(cellAddresses[rowIndex])
            ) {
              if (cellAddresses[rowIndex][colIndex] === cellAddress) {
                rack.userData.cells[rowIndex][colIndex] = {
                  hasMaterial: true,
                  materialId: itemCode,
                  name: itemName,
                  quantity: Now_Qty,
                  date: In_day,
                  status: '양호',
                };
              }
            } else {
              // cellAddresses가 없으면 전체 셀 데이터 매핑
              rack.userData.cells[rowIndex][colIndex] = {
                hasMaterial: true,
                materialId: itemCode,
                name: itemName,
                quantity: Now_Qty,
                date: In_day,
                status: '양호',
              };
            }

            // 해당 셀에 데이터 매핑
            const foundCell = cellMeshes.find(
              (mesh) =>
                mesh.userData.rackId === rackId &&
                mesh.userData.level === rowIndex &&
                mesh.userData.cellIndex === colIndex,
            );
            if (foundCell) {
              foundCell.userData.cellData = { ...rack.userData.cells[rowIndex][colIndex] };
              foundCell.visible = true;

              if (!foundCell.userData.contentMesh) {
                const cellContainer = rack.getObjectByName('cellContainer');
                if (cellContainer) {
                  const standardMaterials = [
                    new THREE.MeshStandardMaterial({
                      color: 0xffff00,
                      metalness: 0.2,
                      roughness: 0.5,
                    }),
                    new THREE.MeshStandardMaterial({
                      color: 0xffff00,
                      metalness: 0.2,
                      roughness: 0.5,
                    }),
                    new THREE.MeshStandardMaterial({
                      color: 0xffff00,
                      metalness: 0.2,
                      roughness: 0.5,
                    }),
                    new THREE.MeshStandardMaterial({
                      color: 0xffff00,
                      metalness: 0.2,
                      roughness: 0.5,
                    }),
                  ];
                  const mat = standardMaterials[colIndex % standardMaterials.length];
                  const boxGeom = new THREE.BoxGeometry(
                    (rack.userData.config.width / rack.userData.config.cells) * 0.8,
                    0.7,
                    rack.userData.config.depth * 0.8,
                  );
                  const boxMesh = new THREE.Mesh(boxGeom, mat);
                  boxMesh.position.copy(foundCell.position);
                  cellContainer.add(boxMesh);
                  foundCell.userData.contentMesh = boxMesh;

                  const sprite = createCellLabel(
                    foundCell.userData.cellData,
                    foundCell.position.x,
                    foundCell.position.y + 0.5,
                    foundCell.position.z,
                  );
                  sprite.userData = { rackId: rackId, cellId: foundCell.userData.cellId };
                  cellContainer.add(sprite);
                  labelSprites.push(sprite);
                }
              }
            }
          });

          // updateHighlightMode();
        } catch (err) {
          console.error('Error in loadDataAndMapForRack:', err);
        }
      }

      // data.json 파일을 불러와, Location에 맞춰 각 셀에 자재 정보를 매핑
      async function loadDataAndMap() {
        try {
          const response = await fetch('rack.json');
          const dataList = await response.json();

          dataList.forEach((item) => {
            const { Location, itemCode, itemName, Now_Qty, In_day } = item;
            const parts = Location.split('-');
            if (parts.length < 3) {
              console.warn('Invalid Location format:', Location);
              return;
            }
            const groupLetter = parts[0];
            const rackNumStr = parts[1];
            const targetRackId = `${groupLetter}-${rackNumStr}`;
            const levelLetter = parts[2].charAt(0).toUpperCase();
            const cellNumStr = parts[2].substring(1);
            const cellNum = parseInt(cellNumStr, 10);

            const rowIndex = levelLetter.charCodeAt(0) - 65;
            const colIndex = cellNum - 1;

            const rackObj = racks.find((r) => r.userData.rackId === targetRackId);
            if (!rackObj) return;

            if (
              rowIndex < rackObj.userData.cells.length &&
              colIndex < rackObj.userData.cells[0].length
            ) {
              rackObj.userData.cells[rowIndex][colIndex] = {
                hasMaterial: true,
                materialId: itemCode,
                name: itemName,
                quantity: Now_Qty,
                date: In_day,
                status: '양호',
              };

              const foundCell = cellMeshes.find(
                (mesh) =>
                  mesh.userData.rackId === targetRackId &&
                  mesh.userData.level === rowIndex &&
                  mesh.userData.cellIndex === colIndex,
              );
              if (foundCell) {
                foundCell.userData.cellData = { ...rackObj.userData.cells[rowIndex][colIndex] };
                foundCell.visible = true;

                if (!foundCell.userData.contentMesh) {
                  const cellContainer = rackObj.getObjectByName('cellContainer');
                  if (cellContainer) {
                    const standardMaterials = [
                      new THREE.MeshStandardMaterial({
                        color: 0xaa3333,
                        metalness: 0.2,
                        roughness: 0.8,
                      }),
                      new THREE.MeshStandardMaterial({
                        color: 0x3333aa,
                        metalness: 0.2,
                        roughness: 0.8,
                      }),
                      new THREE.MeshStandardMaterial({
                        color: 0x33aa33,
                        metalness: 0.2,
                        roughness: 0.8,
                      }),
                      new THREE.MeshStandardMaterial({
                        color: 0xaaaa33,
                        metalness: 0.2,
                        roughness: 0.8,
                      }),
                    ];
                    const col = foundCell.userData.cellIndex;
                    const mat = standardMaterials[col % standardMaterials.length];
                    const boxGeom = new THREE.BoxGeometry(
                      (rackObj.userData.config.width / rackObj.userData.config.cells) * 0.8,
                      0.7,
                      rackObj.userData.config.depth * 0.8,
                    );
                    const boxMesh = new THREE.Mesh(boxGeom, mat);
                    boxMesh.position.copy(foundCell.position);
                    cellContainer.add(boxMesh);
                    foundCell.userData.contentMesh = boxMesh;

                    const sprite = createCellLabel(
                      foundCell.userData.cellData,
                      foundCell.position.x,
                      foundCell.position.y + 0.5,
                      foundCell.position.z,
                    );
                    sprite.userData = { rackId: targetRackId, cellId: foundCell.userData.cellId };
                    cellContainer.add(sprite);
                    labelSprites.push(sprite);
                  }
                }
              }
            }
          });

          // updateHighlightMode();
          console.log('Data mapping completed');
        } catch (err) {
          console.error('Error in loadDataAndMap:', err);
        }
      }

      // 해당 rackId에 해당하는 셀과 라벨을 전역 배열 및 씬에서 제거하는 함수
      function clearGlobalCellsForRack(rackId) {
        // cellMeshes에서 제거
        cellMeshes = cellMeshes.filter((mesh) => {
          if (mesh.userData.rackId === rackId) {
            if (mesh.parent) mesh.parent.remove(mesh);
            if (mesh.geometry) mesh.geometry.dispose();
            if (mesh.material) {
              if (Array.isArray(mesh.material)) {
                mesh.material.forEach((m) => m.dispose());
              } else {
                mesh.material.dispose();
              }
            }
            return false;
          }
          return true;
        });
        // labelSprites에서 제거
        labelSprites = labelSprites.filter((sprite) => {
          if (sprite.userData && sprite.userData.rackId === rackId) {
            if (sprite.parent) sprite.parent.remove(sprite);
            if (sprite.material) sprite.material.dispose();
            return false;
          }
          return true;
        });
      }

      // 랙 요소 정리 함수
      function cleanRackElements(rack) {
        if (!rack || typeof rack.traverse !== 'function') return;

        const rackId = rack.userData.rackId;
        const childrenToRemove = [];

        // 1. 랙의 자식 객체 순회하며 셀과 셀 컨테이너 제거
        rack.traverse((child) => {
          if (child.userData && (child.userData.isCell || child.userData.isCellContainer)) {
            childrenToRemove.push(child);
            disposeResources(child);
          }
        });

        childrenToRemove.forEach((child) => {
          if (child.parent) child.parent.remove(child);
        });

        // 2. 전역 배열에서 해당 랙의 셀과 라벨 제거
        cellMeshes = cellMeshes.filter((mesh) => {
          if (mesh.userData.rackId === rackId) {
            if (mesh.parent) mesh.parent.remove(mesh);
            disposeResources(mesh);
            return false;
          }
          return true;
        });

        labelSprites = labelSprites.filter((sprite) => {
          if (sprite.userData && sprite.userData.rackId === rackId) {
            if (sprite.parent) sprite.parent.remove(sprite);
            disposeResources(sprite);
            return false;
          }
          return true;
        });

        // 3. 툴팁 숨기기
        tooltip.style.display = 'none';
      }

      // function removeRackCompletely(rack) {
      //   // 해당 랙에 속한 모든 자식(셀 컨테이너 포함)을 순회하며 자원을 해제
      //   rack.traverse((child) => {
      //     if (child.geometry) child.geometry.dispose();
      //     if (child.material) {
      //       if (Array.isArray(child.material)) {
      //         child.material.forEach((m) => m.dispose());
      //       } else {
      //         child.material.dispose();
      //       }
      //     }
      //   });
      //   // 전역 셀/라벨 정리
      //   clearGlobalCellsForRack(rack.userData.rackId);
      //   // 씬에서 제거
      //   if (rack.parent) {
      //     rack.parent.remove(rack);
      //   }
      //   // (필요시) 참조 null 처리
      // }

      // 리소스 정리 헬퍼 함수
      function disposeResources(object) {
        if (object.geometry) object.geometry.dispose();
        if (object.material) {
          if (Array.isArray(object.material)) {
            object.material.forEach((m) => m.dispose());
          } else {
            object.material.dispose();
          }
        }
      }

      // UI 업데이트 함수
      function updateRackUI(rotationDeg) {
        if (selectedRacks.length === 1) {
          const rackObj = selectedRacks[0];
          document.getElementById('rack-id').value = rackObj.userData.rackId;
          document.getElementById('rack-rotation').value = rotationDeg;
          document.getElementById('rack-rotation-num').value = rotationDeg;
        } else if (selectedRacks.length > 1) {
          document.getElementById('rack-id').value = '다수 선택됨';
        } else {
          document.getElementById('rack-id').value = '';
        }
      }

      // ── “Apply to all racks” batch routine ──
      async function applyAllRackConfig() {
        const w = parseFloat(document.getElementById('rack-width').value);
        const d = parseFloat(document.getElementById('rack-depth').value);
        const h = parseFloat(document.getElementById('rack-height').value);
        const L = parseInt(document.getElementById('rack-levels').value, 10);
        const C = parseInt(document.getElementById('rack-cells').value, 10);
        const rot = THREE.MathUtils.degToRad(
          parseFloat(document.getElementById('rack-rotation').value),
        );

        const newRacks = [];

        for (const oldRack of racks) {
          const id = oldRack.userData.rackId;
          const pos = oldRack.position.clone();
          const oldGrp = oldRack.userData.config.group || '기본';
          const preserved = oldRack.userData.cells.map((row, i) =>
            row.map((c, j) => `${id}-${String.fromCharCode(65 + i)}${j + 1}`),
          );

          removeRackCompletely(oldRack);

          const nr = createRack(id, w, d, h, L, C);
          nr.position.copy(pos);
          nr.rotation.y = rot;
          // ***** preserve the group *****
          nr.userData.config.group = oldGrp;

          await loadDataAndMapForRack(nr, preserved);
          scene.add(nr);
          newRacks.push(nr);
        }

        racks = newRacks;
        clearSelectedRacks();
        saveAllRackConfigs();
      }

      function disposeRackResources(rack) {
        if (!rack) return;

        rack.traverse((child) => {
          // Dispose geometry
          if (child.geometry) {
            child.geometry.dispose();
          }

          // Dispose material and all textures
          if (child.material) {
            if (Array.isArray(child.material)) {
              child.material.forEach((m) => {
                if (m.map) m.map.dispose();
                if (m.lightMap) m.lightMap.dispose();
                if (m.bumpMap) m.bumpMap.dispose();
                if (m.normalMap) m.normalMap.dispose();
                if (m.specularMap) m.specularMap.dispose();
                if (m.envMap) m.envMap.dispose();
                if (m.aoMap) m.aoMap.dispose();
                if (m.emissiveMap) m.emissiveMap.dispose();
                m.dispose();
              });
            } else {
              if (child.material.map) child.material.map.dispose();
              if (child.material.lightMap) child.material.lightMap.dispose();
              if (child.material.bumpMap) child.material.bumpMap.dispose();
              if (child.material.normalMap) child.material.normalMap.dispose();
              if (child.material.specularMap) child.material.specularMap.dispose();
              if (child.material.envMap) child.material.envMap.dispose();
              if (child.material.aoMap) child.material.aoMap.dispose();
              if (child.material.emissiveMap) child.material.emissiveMap.dispose();
              child.material.dispose();
            }
          }

          // Dispose sprite textures stored in userData
          if (child.userData && child.userData.texture) {
            child.userData.texture.dispose();
          }
          if (child.userData && child.userData.material) {
            child.userData.material.dispose();
          }

          // Handle any custom disposal
          if (child.dispose && typeof child.dispose === 'function') {
            child.dispose();
          }
        });

        // Explicitly nullify references
        rack.children = [];
        rack.userData = {};
      }

      function onMouseMove(event) {
        // 수동 입력값은 드래그 중이 아닐 때 초기화
        if (!isRackDragging) manualDistance = null;

        // 1) 마우스 NDC 변환
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);

        // 2) 랙 드래그 중이면, 선택된 모든 랙에 대해 이동 처리
        if (isRackDragging && selectedRacks.length > 0) {
          // ─ 이동 및 스냅 로직 ─
          selectedRacks.forEach((rack) => {
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), -rack.position.y);
            const intersect = new THREE.Vector3();
            if (raycaster.ray.intersectPlane(plane, intersect)) {
              const offset = rackDragOffsets.get(rack);
              const target = new THREE.Vector3().subVectors(intersect, offset);
              const { halfX: selHX, halfZ: selHZ } = getWorldHalfExtents(rack);

              const snapXs = [],
                snapZs = [];
              racks.forEach((other) => {
                if (other === rack) return;
                const { halfX: oHX, halfZ: oHZ } = getWorldHalfExtents(other);
                snapXs.push(other.position.x - oHX, other.position.x, other.position.x + oHX);
                snapZs.push(other.position.z - oHZ, other.position.z, other.position.z + oHZ);
              });
              snapXs.push(0);
              snapZs.push(0);

              const myXs = [target.x - selHX, target.x, target.x + selHX];
              const myZs = [target.z - selHZ, target.z, target.z + selHZ];

              const TH = 0.5;
              let bestDX = TH,
                chosenX = null;
              snapXs.forEach((cx) => {
                myXs.forEach((mx, i) => {
                  const dx = Math.abs(mx - cx);
                  if (dx < bestDX) {
                    bestDX = dx;
                    chosenX = i === 0 ? cx + selHX : i === 1 ? cx : cx - selHX;
                  }
                });
              });
              if (chosenX !== null) target.x = chosenX;

              let bestDZ = TH,
                chosenZ = null;
              snapZs.forEach((cz) => {
                myZs.forEach((mz, j) => {
                  const dz = Math.abs(mz - cz);
                  if (dz < bestDZ) {
                    bestDZ = dz;
                    chosenZ = j === 0 ? cz + selHZ : j === 1 ? cz : cz - selHZ;
                  }
                });
              });
              if (chosenZ !== null) target.z = chosenZ;

              rack.position.set(target.x, rack.position.y, target.z);
            }
          });

          updateAlignmentHelpers();
          selectedRackHelpers.forEach((h) => h.helper.update());

          // ── 스냅 가이드 이후 측정선 계산 ──
          const dragged = selectedRacks[0];
          let closest = null,
            minDist = Infinity;
          racks.forEach((other) => {
            if (other === dragged || !other.visible) return;
            const d = dragged.position.distanceTo(other.position);
            if (d < minDist) {
              minDist = d;
              closest = other;
            }
          });

          if (closest) {
            const { halfX: hxA, halfZ: hzA } = getWorldHalfExtents(dragged);
            const { halfX: hxB, halfZ: hzB } = getWorldHalfExtents(closest);
            const dir = new THREE.Vector3()
              .subVectors(closest.position, dragged.position)
              .normalize();

            const gap = 0.2; // 랙 표면에서 항상 0.2m 떨어뜨립니다

            // 박스를 dir 방향으로 뚫고 나오는 support 거리 계산
            const supportDistA = Math.abs(dir.x) * hxA + Math.abs(dir.z) * hzA;
            const supportDistB = Math.abs(dir.x) * hxB + Math.abs(dir.z) * hzB;

            // rack edge + gap 만큼 떨어진 위치
            const p1 = dragged.position.clone().add(dir.clone().multiplyScalar(supportDistA + gap));
            const p2 = closest.position
              .clone()
              .add(dir.clone().multiplyScalar(-(supportDistB + gap)));

            // 측정선 생성/업데이트 (기존 로직 그대로)
            if (!measureLine) {
              const geo = new THREE.BufferGeometry().setFromPoints([p1, p2]);
              const mat = new THREE.LineBasicMaterial({ color: 0xff8800 });
              measureLine = new THREE.Line(geo, mat);
              scene.add(measureLine);
            } else {
              measureLine.geometry.setFromPoints([p1, p2]);
            }

            // 거리 텍스트 결정: 수동 입력값 우선
            const rawDist = p1.distanceTo(p2);
            const displayDist = manualDistance !== null ? manualDistance : rawDist;
            const distText = displayDist.toFixed(2) + 'm';
            const mid = p1.clone().lerp(p2, 0.5);

            // 라벨 생성/업데이트
            if (!measureLabel) {
              measureLabel = new CSS2DObject(createLabelElement(distText));
              scene.add(measureLabel);
            } else {
              const span = measureLabel.element.querySelector('span');
              if (span) span.textContent = distText;
              else measureLabel.element.textContent = distText;
            }
            measureLabel.position.copy(mid);

            // 이전 화살표 제거
            arrowHelpers.forEach((a) => scene.remove(a));
            arrowHelpers.length = 0;

            // 화살표 머리 크기
            const headLen = 0.3,
              headWid = 0.2;

            // A 끝 화살표 (B→A 방향)
            const arrowA = new THREE.ArrowHelper(
              dir.clone().negate(),
              p1,
              0,
              0xff8800,
              headLen,
              headWid,
            );
            // B 끝 화살표 (A→B 방향)
            const arrowB = new THREE.ArrowHelper(dir, p2, 0, 0xff8800, headLen, headWid);
            scene.add(arrowA, arrowB);
            arrowHelpers.push(arrowA, arrowB);

            measuringPair = [dragged, closest];
          } else {
            // 측정 대상 없으면 모두 제거
            if (measureLine) {
              scene.remove(measureLine);
              measureLine = null;
            }
            if (measureLabel) {
              scene.remove(measureLabel);
              measureLabel = null;
            }
            arrowHelpers.forEach((a) => scene.remove(a));
            arrowHelpers.length = 0;
            measuringPair = [];
          }

          // 드래그 중일 땐 셀 하이라이트 루틴 건너뜀
          return;
        }

        // 3) 편집 모드면 툴팁만 숨기고 종료
        if (editMode) {
          tooltip.style.display = 'none';
          return;
        }

        // 4) 셀 하이라이트 & 툴팁
        const intersects = raycaster.intersectObjects(cellMeshes, true);
        if (intersects.length > 0) {
          const newCell = intersects[0].object;
          if (hoveredCell !== newCell) {
            if (hoveredCell) resetCellHover(hoveredCell);
            hoveredCell = newCell;
            applyCellHover(hoveredCell);
            updateTooltip(hoveredCell, event.clientX, event.clientY);
          }
        } else {
          if (hoveredCell) {
            resetCellHover(hoveredCell);
            hoveredCell = null;
          }
          tooltip.style.display = 'none';
        }
      }

      function animate() {
        stats.begin();

        controls.update();
        if (editMode && isRackDragging && selectedRacks.length > 0) {
          updateAlignmentHelpers();
        } else {
          alignmentHelpers.forEach((helper) => scene.remove(helper));
          alignmentHelpers = [];
        }

        if (autoRotate && rack) {
          rack.rotation.y += rotationSpeed * 0.01;
        }
        // if (mainLight) {
        //   const time = Date.now() * 0.001;
        //   const lightRadius = 0.5;
        //   mainLight.position.x = 5 + Math.sin(time * 0.5) * lightRadius;
        //   mainLight.position.z = 7 + Math.cos(time * 0.5) * lightRadius;
        // }
        if (labelsVisible) {
          labelSprites.forEach((sprite) => {
            sprite.lookAt(camera.position);
          });
        }

        // 툴바 위치 업데이트 (선택된 랙이 있을 경우)
        if (editMode && selectedRacks.length === 1 && !rackToolbar.classList.contains('hidden')) {
          updateToolbarPosition(selectedRacks[0]);
        }

        selectedRackHelpers.forEach((helperObj) => helperObj.helper.update());

        renderer.render(scene, camera);
        labelRenderer.render(scene, camera);
        stats.end();
        mainAnimationId = requestAnimationFrame(animate);
      }

      // 메인 애니메이션 정리 함수
      let mainAnimationId = null;
      window.stopMainAnimation = function () {
        if (mainAnimationId) {
          cancelAnimationFrame(mainAnimationId);
          mainAnimationId = null;
        }
      };

      function generateUniqueId() {
        return 'uid-' + Date.now() + '-' + Math.floor(Math.random() * 100000);
      }

      // Save current configuration as a template
      function saveRackTemplate() {
        const templateName = document.getElementById('template-name').value.trim();
        if (!templateName) {
          alert('템플릿 이름을 입력하세요.');
          return;
        }

        const width = parseFloat(document.getElementById('rack-width').value) || 5;
        const depth = parseFloat(document.getElementById('rack-depth').value) || 1.5;
        const height = parseFloat(document.getElementById('rack-height').value) || 5;
        const levels = parseInt(document.getElementById('rack-levels').value) || 5;
        const cells = parseInt(document.getElementById('rack-cells').value) || 4;

        const templateId = `template-${Date.now()}`;
        const newTemplate = {
          name: templateName,
          pillar: { color: 0x001cff, metalness: 0.4, roughness: 0.4, thickness: 0.1 }, // Customize via UI later
          shelf: { color: 0xff0000, metalness: 0.2, roughness: 0.6, thickness: 0.1 }, // Customize via UI later
          supports: { enabled: true, diagonal: true },
          dimensions: { width, depth, height, levels, cells },
        };

        rackTemplates[templateId] = newTemplate;
        localStorage.setItem('rackTemplates', JSON.stringify(rackTemplates));
        populateTemplateDropdown();
        alert(`템플릿 "${templateName}"이 저장되었습니다.`);
      }

      // 템플릿 편집 모달 관련 함수
      function showTemplateEditModal(templateId) {
        const template = rackTemplates[templateId];
        if (!template) return;

        const modal = document.getElementById('template-edit-modal');
        document.getElementById('edit-template-name').value = template.name;

        // 색상 처리: 숫자(0xff0000) 또는 문자열("#ff0000") 모두 처리
        const pillarColor = typeof template.pillar.color === 'number'
          ? template.pillar.color
          : parseInt(template.pillar.color.replace('#', ''), 16);
        const shelfColor = typeof template.shelf.color === 'number'
          ? template.shelf.color
          : parseInt(template.shelf.color.replace('#', ''), 16);

        document.getElementById('edit-pillar-color').value = `#${pillarColor.toString(16).padStart(6, '0')}`;
        document.getElementById('edit-shelf-color').value = `#${shelfColor.toString(16).padStart(6, '0')}`;
        document.getElementById('edit-pillar-thickness').value = template.pillar.thickness;
        document.getElementById('edit-shelf-thickness').value = template.shelf.thickness;
        document.getElementById('edit-diagonal-supports').checked = template.supports.diagonal;
        document.getElementById('edit-shelf-plate').checked = template.shelfPlate || false;
        document.getElementById('edit-top-plate').checked = template.topPlate || false;

        modal.dataset.templateId = templateId;
        modal.style.display = 'block';

        if (!previewRenderer) initPreviewCanvas();
        updatePreviewRack();
      }

      function hideTemplateEditModal() {
        document.getElementById('template-edit-modal').style.display = 'none';
        if (previewRack) {
          previewScene.remove(previewRack);
          previewRack.traverse((child) => {
            if (child.geometry) child.geometry.dispose();
            if (child.material) child.material.dispose();
          });
          previewRack = null;
        }
      }

      // 새 템플릿 추가
      function addNewTemplate() {
        const name = document.getElementById('edit-template-name').value.trim();
        if (!name) {
          alert('템플릿 이름을 입력하세요.');
          return;
        }

        if (isTemplateNameDuplicate(name)) {
          alert('이미 존재하는 템플릿 이름입니다. 다른 이름을 입력하세요.');
          return;
        }

        const pillarColorHex = document.getElementById('edit-pillar-color').value; // "#rrggbb"
        const shelfColorHex = document.getElementById('edit-shelf-color').value; // "#rrggbb"

        // Hex 문자열을 숫자로 변환 (일관성 유지)
        const pillarColor = parseInt(pillarColorHex.replace('#', ''), 16);
        const shelfColor = parseInt(shelfColorHex.replace('#', ''), 16);

        const pillarThickness =
          parseFloat(document.getElementById('edit-pillar-thickness').value) || 0.1;
        const shelfThickness =
          parseFloat(document.getElementById('edit-shelf-thickness').value) || 0.1;
        const diagonalSupports = document.getElementById('edit-diagonal-supports').checked;
        const shelfPlate = document.getElementById('edit-shelf-plate').checked;
        const topPlate = document.getElementById('edit-top-plate').checked;

        const templateId = `template-${Date.now()}`;
        rackTemplates[templateId] = {
          name,
          pillar: {
            color: pillarColor, // 숫자로 저장
            metalness: 0.4,
            roughness: 0.4,
            thickness: Math.max(0.05, Math.min(0.5, pillarThickness)),
          },
          shelf: {
            color: shelfColor, // 숫자로 저장
            metalness: 0.2,
            roughness: 0.6,
            thickness: Math.max(0.05, Math.min(0.5, shelfThickness)),
          },
          supports: { enabled: true, diagonal: diagonalSupports },
          shelfPlate: shelfPlate,
          topPlate: topPlate,
        };

        localStorage.setItem('rackTemplates', JSON.stringify(rackTemplates));
        populateTemplateThumbnails();
        selectedTemplateId = templateId;
        document.getElementById('selected-template-id').value = templateId;
        alert(`새 템플릿 "${name}"이 추가되었습니다.`);
      }

      // 템플릿 변경 저장
      function saveTemplateChanges() {
        const modal = document.getElementById('template-edit-modal');
        const templateId = modal.dataset.templateId;
        if (!templateId || !rackTemplates[templateId]) return;

        const name = document.getElementById('edit-template-name').value.trim();
        if (!name) {
          alert('템플릿 이름을 입력하세요.');
          return;
        }

        if (isTemplateNameDuplicate(name, templateId)) {
          alert('이미 존재하는 템플릿 이름입니다. 다른 이름을 입력하세요.');
          return;
        }

        const pillarColorHex = document.getElementById('edit-pillar-color').value; // "#rrggbb"
        const shelfColorHex = document.getElementById('edit-shelf-color').value; // "#rrggbb"

        // Hex 문자열을 숫자로 변환 (일관성 유지)
        const pillarColor = parseInt(pillarColorHex.replace('#', ''), 16);
        const shelfColor = parseInt(shelfColorHex.replace('#', ''), 16);

        const pillarThickness =
          parseFloat(document.getElementById('edit-pillar-thickness').value) || 0.1;
        const shelfThickness =
          parseFloat(document.getElementById('edit-shelf-thickness').value) || 0.1;
        const diagonalSupports = document.getElementById('edit-diagonal-supports').checked;
        const shelfPlate = document.getElementById('edit-shelf-plate').checked;
        const topPlate = document.getElementById('edit-top-plate').checked;

        rackTemplates[templateId] = {
          ...rackTemplates[templateId],
          name,
          pillar: {
            ...rackTemplates[templateId].pillar,
            color: pillarColor, // 숫자로 저장
            thickness: Math.max(0.05, Math.min(0.5, pillarThickness)),
          },
          shelf: {
            ...rackTemplates[templateId].shelf,
            color: shelfColor, // 숫자로 저장
            thickness: Math.max(0.05, Math.min(0.5, shelfThickness)),
          },
          supports: { ...rackTemplates[templateId].supports, diagonal: diagonalSupports },
          shelfPlate: shelfPlate,
          topPlate: topPlate,
        };

        localStorage.setItem('rackTemplates', JSON.stringify(rackTemplates));
        populateTemplateThumbnails();
        updateRacksWithTemplate(templateId);
        hideTemplateEditModal();
        alert(`템플릿 "${name}"이 수정되었습니다.`);
      }

      // 실시간 업데이트 이벤트 리스너
      document
        .querySelectorAll(
          '#edit-pillar-color, #edit-shelf-color, #edit-pillar-thickness, #edit-shelf-thickness, #edit-diagonal-supports, #edit-shelf-plate, #edit-top-plate',
        )
        .forEach((input) => {
          input.addEventListener('input', updatePreviewRack);
        });

      // 선택된 템플릿을 사용하는 모든 랙 업데이트
      function updateRacksWithTemplate(templateId) {
        const affectedRacks = racks.filter((rack) => rack.userData.templateId === templateId);
        if (affectedRacks.length === 0) return;

        affectedRacks.forEach(async (oldRack) => {
          const rackId = oldRack.userData.rackId;
          const pos = oldRack.position.clone();
          const rotation = oldRack.rotation.y;
          const config = oldRack.userData.config;
          const preservedCells = oldRack.userData.cells;  // 셀 데이터 보존
          const preservedCellAddresses = oldRack.userData.cells.map((row, rowIdx) =>
            row.map((cell, colIdx) => `${rackId}-${String.fromCharCode(65 + rowIdx)}${colIdx + 1}`),
          );

          removeRackCompletely(oldRack);
          racks = racks.filter((r) => r.userData.rackId !== rackId);

          const newRack = createRack(
            rackId,
            config.width,
            config.depth,
            config.height,
            config.levels,
            config.cells,
            preservedCells,  // 셀 데이터 전달
            true,            // isNewRack
            templateId,
          );

          // 위치와 회전 복원
          newRack.position.copy(pos);
          newRack.rotation.y = rotation;
          newRack.userData.config.rotation = THREE.MathUtils.radToDeg(rotation);
          newRack.updateMatrixWorld(true);

          await loadDataAndMapForRack(newRack, preservedCellAddresses);
          racks.push(newRack);
          scene.add(newRack);
        });

        saveAllRackConfigs();
        renderer.render(scene, camera);
      }

      // 이벤트 리스너 추가
      document.getElementById('edit-template').addEventListener('click', () => {
        const templateId = document.getElementById('template-select').value;
        showTemplateEditModal(templateId);
      });

      // 템플릿 썸네일 생성
      function generateTemplateThumbnail(templateId, template) {
        // 임시 캔버스 설정
        const canvas = document.createElement('canvas');
        canvas.width = 60;
        canvas.height = 60;
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 1000);
        camera.position.set(3, 3, 3);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({
          canvas: canvas,
          antialias: true,
          preserveDrawingBuffer: true,
        });
        renderer.setSize(60, 60);
        renderer.setClearColor(0xdddddd);

        // 조명 추가
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
        directionalLight.position.set(5, 5, 5);
        scene.add(directionalLight);

        // 임시 랙 생성
        const tempRack = createRack('temp', 2, 1, 1, 2, 2, null, false, templateId, template);
        scene.add(tempRack);

        // 렌더링
        renderer.render(scene, camera);

        // 썸네일 이미지 URL 생성
        const thumbnailUrl = canvas.toDataURL('image/png');

        // 리소스 정리
        scene.remove(tempRack);
        tempRack.traverse((child) => {
          if (child.geometry) child.geometry.dispose();
          if (child.material) child.material.dispose();
        });
        // 'temp' 및 'preview' rackId를 가진 유령 셀과 라벨 제거
        cellMeshes = cellMeshes.filter(
          (mesh) => mesh.userData.rackId !== 'temp' && mesh.userData.rackId !== 'preview',
        );
        labelSprites = labelSprites.filter(
          (sprite) => sprite.userData.rackId !== 'temp' && sprite.userData.rackId !== 'preview',
        );
        renderer.dispose();
        racks = racks.filter(
          (r) => r.userData.rackId !== 'temp' && r.userData.rackId !== 'preview',
        );

        return thumbnailUrl;
      }

      // 템플릿 썸네일 UI 생성
      function populateTemplateThumbnails() {
        const thumbnailsContainer = document.getElementById('template-thumbnails');
        if (!thumbnailsContainer) {
          console.error('template-thumbnails element not found');
          return;
        }
        thumbnailsContainer.innerHTML = '';

        Object.entries(rackTemplates).forEach(([templateId, template]) => {
          // 썸네일 생성
          const thumbnailUrl = generateTemplateThumbnail(templateId, template);

          // 썸네일 요소 생성
          const thumbnailDiv = document.createElement('div');
          thumbnailDiv.className = 'relative';

          const img = document.createElement('img');
          img.src = thumbnailUrl;
          img.className = `thumbnail ${templateId === selectedTemplateId ? 'selected' : ''}`;
          img.dataset.templateId = templateId;
          img.title = template.name; // 툴팁으로 템플릿 이름 표시

          // 템플릿 이름 표시
          const nameLabel = document.createElement('div');
          nameLabel.className = 'text-xs text-center mt-1';
          nameLabel.textContent = template.name;

          thumbnailDiv.appendChild(img);
          thumbnailDiv.appendChild(nameLabel);
          thumbnailsContainer.appendChild(thumbnailDiv);

          // 썸네일 클릭 이벤트
          img.addEventListener('click', () => {
            // 이전 선택 해제
            document
              .querySelectorAll('.thumbnail')
              .forEach((thumb) => thumb.classList.remove('selected'));
            // 현재 선택 표시
            img.classList.add('selected');
            selectedTemplateId = templateId;
            document.getElementById('selected-template-id').value = templateId;
          });
        });
      }

      // 모달창 열기
      function showFloorEditModal() {
        const modal = document.getElementById('floor-edit-modal');
        modal.style.display = 'block';

        if (!floorPreviewRenderer) initFloorPreviewCanvas();
        updateFloorPreview();
      }

      // 모달창 닫기
      function hideFloorEditModal() {
        const modal = document.getElementById('floor-edit-modal');
        modal.style.display = 'none';

        // 미리보기 정리
        if (floorPreviewMesh) {
          floorPreviewScene.remove(floorPreviewMesh);
          floorPreviewMesh.geometry.dispose();
          floorPreviewMesh.material.dispose();
          floorPreviewMesh = null;
        }
      }

      // 미리보기 업데이트
      function updateFloorPreview() {
        const canvas = document.getElementById('floor-preview-canvas');
        // 캔버스 크기 동적 조정
        canvas.width = canvas.clientWidth;
        canvas.height = canvas.clientHeight;
        floorPreviewRenderer.setSize(canvas.clientWidth, canvas.clientHeight);
        floorPreviewCamera.aspect = canvas.clientWidth / canvas.clientHeight;
        floorPreviewCamera.updateProjectionMatrix();

        const width = parseFloat(document.getElementById('floor-width').value) || 100;
        const depth = parseFloat(document.getElementById('floor-depth').value) || 100;
        const color = parseInt(document.getElementById('floor-color').value.replace('#', ''), 16);
        const thickness = parseFloat(document.getElementById('floor-thickness').value) || 0.2;
        const materialType = document.getElementById('floor-material').value;
        const opacity = parseFloat(document.getElementById('floor-opacity').value) || 1;
        const receiveShadow = document.getElementById('floor-shadow').checked;

        if (floorPreviewMesh) {
          floorPreviewScene.remove(floorPreviewMesh);
          floorPreviewMesh.geometry.dispose();
          floorPreviewMesh.material.dispose();
        }

        const geometry = new THREE.BoxGeometry(width / 10, thickness, depth / 10); // 미리보기는 축소
        let material;
        if (materialType === 'custom') {
          material = new THREE.MeshStandardMaterial({
            color: color,
            roughness: 0.8,
            metalness: 0.2,
            transparent: true,
            opacity: opacity,
          });
        } else {
          material = new THREE.MeshStandardMaterial({
            map: textures[materialType],
            roughness: 0.9,
            metalness: 0.1,
            transparent: true,
            opacity: opacity,
          });
        }

        floorPreviewMesh = new THREE.Mesh(geometry, material);
        floorPreviewMesh.position.y = thickness / 2; // 미리보기에서도 두께만 반영
        floorPreviewMesh.receiveShadow = receiveShadow;
        floorPreviewMesh.castShadow = true;
        floorPreviewScene.add(floorPreviewMesh);

        floorPreviewRenderer.render(floorPreviewScene, floorPreviewCamera);
      }

      // 바닥 설정 저장 및 적용
      function saveFloorChanges() {
        const name = document.getElementById('floor-name').value.trim();
        const config = getCurrentFloorConfig();

        if (!name) {
          alert('바닥 이름을 입력하세요.');
          return;
        }

        createFloor({ ...config, name });
        hideFloorEditModal();
        alert(`바닥 "${name}"이 적용되었습니다.`);
      }

      function toggleMode() {
        isEditMode = !isEditMode;
        console.log('Toggling mode, isEditMode:', isEditMode); // 디버깅 로그
        // 현재 모달창에서 설정된 바닥 구성값 가져오기 (없으면 기본값 사용)
        const config = getCurrentFloorConfig();
        createFloor({ ...config, isEditMode: editMode });

        // 랙 위치 재조정
        racks.forEach((rack) => {
          const floorHeight = floorMesh ? floorMesh.position.y : 0;
          const bbox = new THREE.Box3().setFromObject(rack);
          const minY = bbox.min.y;
          if (minY < floorHeight) {
            rack.position.y += floorHeight - minY;
          }
        });

        renderer.render(scene, camera);
      }

      function getFloorTopY() {
        // floorMesh.position.y = thickness/2, geometry.parameters.height = thickness
        return floorMesh.position.y + floorMesh.geometry.parameters.height / 2;
      }

      // 현재 모달창에서 설정된 바닥 구성값 가져오기
      function getCurrentFloorConfig() {
        return {
          width: parseFloat(document.getElementById('floor-width').value) || 100,
          depth: parseFloat(document.getElementById('floor-depth').value) || 100,
          color:
            parseInt(document.getElementById('floor-color').value.replace('#', ''), 16) || 0xb0b0b0,
          thickness: parseFloat(document.getElementById('floor-thickness').value) || 0.2, // 두께
          materialType: document.getElementById('floor-material').value || 'custom',
          opacity: parseFloat(document.getElementById('floor-opacity').value) || 1,
          receiveShadow: document.getElementById('floor-shadow').checked,
          isEditMode: isEditMode,
        };
      }

      // 예: 커스텀 Path → TubeGeometry 로 외곽 루프만 그리기
      // function addOuterSquareBorder(
      //   rack,
      //   {
      //     margin = 0.1,
      //     height = 0.01,
      //     lineWidth = 4, // 화면 픽셀 단위 4px
      //     color = 0xffff00,
      //   } = {},
      // ) {
      //   if (rack.userData.outerLine) {
      //     rack.remove(rack.userData.outerLine);
      //     rack.userData.outerLine.geometry.dispose();
      //     rack.userData.outerLine.material.dispose();
      //     delete rack.userData.outerLine;
      //   }

      //   const { width, depth } = rack.userData.config;
      //   const w = width + margin * 2;
      //   const d = depth + margin * 2;
      //   const y = height;

      //   const pts = [
      //     -w / 2,
      //     y,
      //     -d / 2,
      //     w / 2,
      //     y,
      //     -d / 2,
      //     w / 2,
      //     y,
      //     d / 2,
      //     -w / 2,
      //     y,
      //     d / 2,
      //     -w / 2,
      //     y,
      //     -d / 2,
      //   ];

      //   const geometry = new LineGeometry();
      //   geometry.setPositions(pts);

      //   const material = new LineMaterial({
      //     color: color,
      //     linewidth: lineWidth, // 픽셀 단위 굵기
      //     worldUnits: false, // ← 화면 공간(pixels)
      //   });
      //   material.resolution.set(window.innerWidth, window.innerHeight);

      //   const line = new Line2(geometry, material);
      //   line.frustumCulled = false;
      //   rack.add(line);
      //   rack.userData.outerLine = line;

      //   window.addEventListener('resize', () => {
      //     material.resolution.set(window.innerWidth, window.innerHeight);
      //   });
      // }

      // 바닥 템플릿 저장
      function saveFloorTemplate() {
        const name = document.getElementById('floor-name').value.trim();
        const width = parseFloat(document.getElementById('floor-width').value) || 100;
        const depth = parseFloat(document.getElementById('floor-depth').value) || 100;
        const colorHex = document.getElementById('floor-color').value;
        const thickness = parseFloat(document.getElementById('floor-thickness').value) || 0.2;
        const materialType = document.getElementById('floor-material').value;
        const opacity = parseFloat(document.getElementById('floor-opacity').value) || 1;
        const receiveShadow = document.getElementById('floor-shadow').checked;
        const setAsDefault = document.getElementById('set-default-floor').checked;

        if (!name) {
          alert('바닥 이름을 입력하세요.');
          return;
        }

        const templateId = `floor-${Date.now()}`;
        floorTemplates[templateId] = {
          name,
          width,
          depth,
          color: colorHex,
          thickness, // 두께만 저장
          materialType,
          opacity,
          receiveShadow,
        };

        localStorage.setItem('floorTemplates', JSON.stringify(floorTemplates));

        if (setAsDefault) {
          defaultSettings.defaultFloorTemplateId = templateId;
          saveDefaultSettings();
          alert(`바닥 템플릿 "${name}"이 저장되고 기본 템플릿으로 설정되었습니다.`);
        } else {
          alert(`바닥 템플릿 "${name}"이 저장되었습니다.`);
        }
      }

      // 이벤트 리스너 등록
      document.getElementById('toggle-edit-mode').addEventListener('click', () => {
        setEditMode(!isEditMode);
        updateShadowQuality();
        updateCellVisibility();
      });
      // document.getElementById('add-floor-button').addEventListener('click', showFloorEditModal);
      // document.getElementById('floor-modal-close').addEventListener('click', hideFloorEditModal);
      // document.getElementById('save-floor-changes').addEventListener('click', saveFloorChanges);
      // document.getElementById('cancel-floor-changes').addEventListener('click', hideFloorEditModal);
      // document.getElementById('save-floor-template').addEventListener('click', saveFloorTemplate);

      // GSAP 사용해 카메라를 셀 중앙으로 이동시키고, OrbitControls도 따라가게 하는 함수
      // matchedCells: 검색된 THREE.Mesh 들의 배열
      function focusOnMeshes(matchedCells) {
        if (matchedCells.length === 0) return;

        // 1) 여러 메시를 감싸는 바운딩 박스
        const box = new THREE.Box3();
        matchedCells.forEach((m) => box.expandByObject(m));
        const center = box.getCenter(new THREE.Vector3());
        const size = box.getSize(new THREE.Vector3()).length();

        // 2) 적당한 거리 계산 (박스 크기 기반)
        const distance = size * 1.2;

        // 3) 카메라가 있을 목표 위치
        //    - 전방(Z) 으로 distance * 1.5 (더 멀리)
        //    - 위(Y) 로 distance * 0.8  (더 높게)
        const offset = new THREE.Vector3(0, distance * 3, distance * 7);
        const targetPos = center.clone().add(offset);

        // 4) GSAP 으로 애니메이션
        gsap.to(camera.position, {
          x: targetPos.x,
          y: targetPos.y,
          z: targetPos.z,
          duration: 2,
          ease: 'power2.inOut',
          onUpdate: () => {
            camera.lookAt(center);
            controls.update();
          },
        });

        // 5) OrbitControls 의 타겟도 셀 중심으로 애니메이션
        gsap.to(controls.target, {
          x: center.x,
          y: center.y,
          z: center.z,
          duration: 1.2,
          ease: 'power2.inOut',
          onUpdate: () => controls.update(),
        });
      }

      // 검색 버튼 클릭 핸들러
      document.getElementById('search-btn').addEventListener('click', () => {
        const searchCode = document.getElementById('search-input').value.trim();
        clearSearchHighlights();
        if (!searchCode) return;

        // 올바르게 필터링
        const matchedCells = cellMeshes.filter(
          (mesh) => mesh.userData.cellData.materialId === searchCode,
        );
        if (matchedCells.length === 0) {
          alert('해당 품목코드를 찾을 수 없습니다.');
          return;
        }

        // 2) 깜빡임 효과 (contentMesh만)
        matchedCells.forEach((mesh) => {
          const box = mesh.userData.contentMesh;
          let visible = true;
          const timer = setInterval(() => {
            box.visible = visible;
            visible = !visible;
          }, 400);
          blinkTimers.push(timer);
        });

        // 3) 카메라 포커스
        focusOnMeshes(matchedCells);

        // 4) 랙 위에 빨간 화살표 추가
        const racks = new Set();
        matchedCells.forEach((mesh) => {
          let o = mesh;
          while (o && !o.userData.isRack) o = o.parent;
          if (o) racks.add(o);
        });
        racks.forEach((rack) => {
          const arrow = createArrowAboveRack(rack);
          arrowHelpers.push(arrow);
          scene.add(arrow);
        });
      });

      // 검색 하이라이트 정리 함수
      function clearSearchHighlights() {
        blinkTimers.forEach((t) => clearInterval(t));
        blinkTimers.length = 0;

        cellMeshes.forEach((mesh) => {
          if (mesh.userData.contentMesh) mesh.userData.contentMesh.visible = true;
        });

        arrowHelpers.forEach((a) => scene.remove(a));
        arrowHelpers.length = 0;
      }

      function updateCellVisibility() {
        cellMeshes.forEach((mesh) => {
          mesh.visible = !isEditMode || mesh.userData.cellData.hasMaterial;
          mesh.frustumCulled = !isEditMode;
        });
      }

      // FPS 토글 초기화 함수
      function initializeFPSToggle() {
        const fpsToggle = document.getElementById('fps-toggle');
        const fpsStatusIndicator = document.getElementById('fps-status-indicator');

        // stats가 초기화되었는지 확인
        let performanceMonitorElement = null;
        if (stats && stats.dom) {
          if (!document.body.contains(stats.dom)) {
            document.body.appendChild(stats.dom);
          }
          performanceMonitorElement = stats.dom;
        } else {
          console.warn('stats is not initialized yet');
          return; // stats가 없으면 조기 종료
        }

        function updatePerformanceMonitorVisibility() {
          if (!performanceMonitorElement) {
            console.warn('Performance monitor element is not available');
            return;
          }

          if (fpsToggle && fpsToggle.checked) {
            performanceMonitorElement.style.display = 'block';
            if (fpsStatusIndicator) fpsStatusIndicator.textContent = '표시 중';
          } else {
            performanceMonitorElement.style.display = 'none';
            if (fpsStatusIndicator) fpsStatusIndicator.textContent = '숨김';
          }
        }

        // Add event listener to the toggle
        if (fpsToggle) {
          fpsToggle.addEventListener('change', updatePerformanceMonitorVisibility);
          // Set initial state
          updatePerformanceMonitorVisibility();
        }
      }

      // 랙 위에 화살표를 띄워 주는 헬퍼 (이미 작성하신 그대로 사용)
      function createArrowAboveRack(rack) {
        const bbox = new THREE.Box3().setFromObject(rack);
        const origin = rack.position.clone();
        origin.y = bbox.max.y + 0.5;

        const dir = new THREE.Vector3(0, -1, 0);
        const length = 0.6;
        const headLen = 0.3;
        const headWidth = 0.2;
        return new THREE.ArrowHelper(dir, origin, length, 0xff0000, headLen, headWidth);
      }

      // 실시간 미리보기 이벤트
      document
        .querySelectorAll(
          '#floor-width, #floor-depth, #floor-color, #floor-thickness, #floor-material, #floor-opacity, #floor-shadow',
        )
        .forEach((input) => {
          input.addEventListener('input', updateFloorPreview);
        });

      function clearMeasurementVisuals() {
        // 측정선 제거
        if (measureLine) {
          scene.remove(measureLine);
          measureLine.geometry.dispose();
          measureLine.material.dispose();
          measureLine = null;
        }

        // 라벨 제거
        if (measureLabel) {
          scene.remove(measureLabel);
          measureLabel.element.remove(); // CSS2DRenderer DOM도 함께 제거
          measureLabel = null;
        }

        // 화살표 제거
        arrowHelpers.forEach((arrow) => scene.remove(arrow));
        arrowHelpers.length = 0;

        // 툴팁 숨김
        tooltip.style.display = 'none';
      }

      // 바닥 템플릿 로드
      function loadFloorTemplatesFromStorage() {
        const storedTemplates = localStorage.getItem('floorTemplates');
        if (storedTemplates) {
          floorTemplates = JSON.parse(storedTemplates);
        } else {
          floorTemplates = {};
          localStorage.setItem('floorTemplates', JSON.stringify(floorTemplates));
        }
      }

      // 회전각도
      const rotValue = document.getElementById('cfg-rotation-value');
      const rotRange = document.getElementById('cfg-rotation-range');

      // 조명 밝기
      const lightValue = document.getElementById('light-value');
      const lightRange = document.getElementById('light-range');

      // 2) --percent 계산 함수
      function updateSliderPercent(slider) {
        const min = parseFloat(slider.min);
        const max = parseFloat(slider.max);
        const val = parseFloat(slider.value);
        const pct = ((val - min) / (max - min)) * 100;
        slider.style.setProperty('--percent', `${pct}%`);
      }

      function bindRange(valueInput, rangeInput, onChange) {
        // 초기 --percent 세팅
        updateSliderPercent(rangeInput);

        // 숫자 입력 → 슬라이더
        valueInput.addEventListener('input', () => {
          let v = parseFloat(valueInput.value);
          if (isNaN(v)) v = parseFloat(rangeInput.min);
          v = Math.max(rangeInput.min, Math.min(rangeInput.max, v));
          rangeInput.value = v;
          updateSliderPercent(rangeInput);
          if (onChange) onChange(v);
        });

        // 슬라이더 → 숫자 입력
        rangeInput.addEventListener('input', () => {
          const v = parseFloat(rangeInput.value);
          valueInput.value = v;
          updateSliderPercent(rangeInput);
          if (onChange) onChange(v);
        });
      }

      // 회전각도 바인딩 (회전 업데이트 콜백)
      bindRange(
        document.getElementById('cfg-rotation-value'),
        document.getElementById('cfg-rotation-range'),
        (v) => {
          // 회전 변경 시 설정 즉시 적용
          if (typeof applyCfgPanelConfig === 'function') {
            applyCfgPanelConfig();
          }
        },
      );

      // 조명 밝기 바인딩 (조명 업데이트 콜백)
      bindRange(
        document.getElementById('light-value'),
        document.getElementById('light-range'),
        (v) => {
          updateLightIntensity(v);
        },
      );

      // 초기 채우기
      //updateLight();
      // 초기 로드
      loadFloorTemplatesFromStorage();

      // document.getElementById('add-rack-border').addEventListener('click', () => {
      //   racks.forEach((rack) => {
      //     addOuterSquareBorder(rack, {
      //       margin: 0.3, // 원하는 여유(m)
      //       height: 0.02, // 바닥 위 띄울 높이(m)
      //       lineWidth: 4, // 월드 단위 두께(m)
      //       color: 0xffff00, // 노란색
      //     });
      //   });
      // });

      document.getElementById('save-floor-changes').addEventListener('click', saveFloorChanges);
      document
        .getElementById('template-modal-close')
        .addEventListener('click', hideTemplateEditModal);
      document
        .getElementById('cancel-template-changes')
        .addEventListener('click', hideTemplateEditModal);
      document
        .getElementById('save-template-changes')
        .addEventListener('click', saveTemplateChanges);
      document.getElementById('add-new-template').addEventListener('click', addNewTemplate);

      // 템플릿 편집 모달 입력 필드에 디바운스된 미리보기 업데이트 추가 (기존 debounce 함수 재사용)
      const debouncedUpdatePreview = debounce(updatePreviewRack, 300); // 300ms 디바운스

      // 컬러피커와 다른 입력 필드에 이벤트 리스너 추가
      document.getElementById('edit-pillar-color').addEventListener('input', debouncedUpdatePreview);
      document.getElementById('edit-shelf-color').addEventListener('input', debouncedUpdatePreview);
      document.getElementById('edit-pillar-thickness').addEventListener('input', debouncedUpdatePreview);
      document.getElementById('edit-shelf-thickness').addEventListener('input', debouncedUpdatePreview);
      document.getElementById('edit-diagonal-supports').addEventListener('change', updatePreviewRack);
      document.getElementById('edit-shelf-plate').addEventListener('change', updatePreviewRack);
      document.getElementById('edit-top-plate').addEventListener('change', updatePreviewRack);

      window.onload = init;
    </script>
  </body>
</html>
